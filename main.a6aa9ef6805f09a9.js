(self.webpackChunkportifolio = self.webpackChunkportifolio || []).push([[179], { 434: (Yr, gt, le) => { "use strict"; function k(e) { return "function" == typeof e } function ie(e) { const n = e(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const ee = ie(e => function (n) { e(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, i) => `${i + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function Ge(e, t) { if (e) { const n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } class oe { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const o of n) o.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (k(r)) try { r() } catch (o) { t = o instanceof ee ? o.errors : [o] } const { _finalizers: i } = this; if (i) { this._finalizers = null; for (const o of i) try { T(o) } catch (s) { t = null != t ? t : [], s instanceof ee ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new ee(t) } } add(t) { var n; if (t && t !== this) if (this.closed) T(t); else { if (t instanceof oe) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(t) } } _hasParent(t) { const { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { const { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && Ge(n, t) } remove(t) { const { _finalizers: n } = this; n && Ge(n, t), t instanceof oe && t._removeParent(this) } } oe.EMPTY = (() => { const e = new oe; return e.closed = !0, e })(); const Be = oe.EMPTY; function se(e) { return e instanceof oe || e && "closed" in e && k(e.remove) && k(e.add) && k(e.unsubscribe) } function T(e) { k(e) ? e() : e.unsubscribe() } const D = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, E = { setTimeout(e, t, ...n) { const { delegate: r } = E; return (null == r ? void 0 : r.setTimeout) ? r.setTimeout(e, t, ...n) : setTimeout(e, t, ...n) }, clearTimeout(e) { const { delegate: t } = E; return ((null == t ? void 0 : t.clearTimeout) || clearTimeout)(e) }, delegate: void 0 }; function w(e) { E.setTimeout(() => { const { onUnhandledError: t } = D; if (!t) throw e; t(e) }) } function y() { } const G = Jt("C", void 0, void 0); function Jt(e, t, n) { return { kind: e, value: t, error: n } } let Pe = null; function yn(e) { if (D.useDeprecatedSynchronousErrorHandling) { const t = !Pe; if (t && (Pe = { errorThrown: !1, error: null }), e(), t) { const { errorThrown: n, error: r } = Pe; if (Pe = null, n) throw r } } else e() } class qs extends oe { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, se(t) && t.add(this)) : this.destination = Av } static create(t, n, r) { return new io(t, n, r) } next(t) { this.isStopped ? Ws(function Ve(e) { return Jt("N", e, void 0) }(t), this) : this._next(t) } error(t) { this.isStopped ? Ws(function ce(e) { return Jt("E", void 0, e) }(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? Ws(G, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const Iv = Function.prototype.bind; function Gs(e, t) { return Iv.call(e, t) } class Tv { constructor(t) { this.partialObserver = t } next(t) { const { partialObserver: n } = this; if (n.next) try { n.next(t) } catch (r) { oo(r) } } error(t) { const { partialObserver: n } = this; if (n.error) try { n.error(t) } catch (r) { oo(r) } else oo(t) } complete() { const { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (n) { oo(n) } } } class io extends qs { constructor(t, n, r) { let i; if (super(), k(t) || !t) i = { next: null != t ? t : void 0, error: null != n ? n : void 0, complete: null != r ? r : void 0 }; else { let o; this && D.useDeprecatedNextContext ? (o = Object.create(t), o.unsubscribe = () => this.unsubscribe(), i = { next: t.next && Gs(t.next, o), error: t.error && Gs(t.error, o), complete: t.complete && Gs(t.complete, o) }) : i = t } this.destination = new Tv(i) } } function oo(e) { D.useDeprecatedSynchronousErrorHandling ? function Kr(e) { D.useDeprecatedSynchronousErrorHandling && Pe && (Pe.errorThrown = !0, Pe.error = e) }(e) : w(e) } function Ws(e, t) { const { onStoppedNotification: n } = D; n && E.setTimeout(() => n(e, t)) } const Av = { closed: !0, next: y, error: function Sv(e) { throw e }, complete: y }, Qs = "function" == typeof Symbol && Symbol.observable || "@@observable"; function Fn(e) { return e } let Me = (() => { class e { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new e; return r.source = this, r.operator = n, r } subscribe(n, r, i) { const o = function Rv(e) { return e && e instanceof qs || function xv(e) { return e && k(e.next) && k(e.error) && k(e.complete) }(e) && se(e) }(n) ? n : new io(n, r, i); return yn(() => { const { operator: s, source: a } = this; o.add(s ? s.call(o, a) : a ? this._subscribe(o) : this._trySubscribe(o)) }), o } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = Lc(r))((i, o) => { const s = new io({ next: a => { try { n(a) } catch (u) { o(u), s.unsubscribe() } }, error: o, complete: i }); this.subscribe(s) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [Qs]() { return this } pipe(...n) { return function kc(e) { return 0 === e.length ? Fn : 1 === e.length ? e[0] : function (n) { return e.reduce((r, i) => i(r), n) } }(n)(this) } toPromise(n) { return new (n = Lc(n))((r, i) => { let o; this.subscribe(s => o = s, s => i(s), () => r(o)) }) } } return e.create = t => new e(t), e })(); function Lc(e) { var t; return null !== (t = null != e ? e : D.Promise) && void 0 !== t ? t : Promise } const Pv = ie(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let Xt = (() => { class e extends Me { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new jc(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new Pv } next(n) { yn(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(n) } }) } error(n) { yn(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { yn(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: i, observers: o } = this; return r || i ? Be : (this.currentObservers = null, o.push(n), new oe(() => { this.currentObservers = null, Ge(o, n) })) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: i, isStopped: o } = this; r ? n.error(i) : o && n.complete() } asObservable() { const n = new Me; return n.source = this, n } } return e.create = (t, n) => new jc(t, n), e })(); class jc extends Xt { constructor(t, n) { super(), this.destination = t, this.source = n } next(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, t) } error(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, t) } complete() { var t, n; null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === n || n.call(t) } _subscribe(t) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(t)) && void 0 !== r ? r : Be } } function Bc(e) { return k(null == e ? void 0 : e.lift) } function Oe(e) { return t => { if (Bc(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function Ne(e, t, n, r, i) { return new Ov(e, t, n, r, i) } class Ov extends qs { constructor(t, n, r, i, o, s) { super(t), this.onFinalize = o, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (u) { t.error(u) } } : super._next, this._error = i ? function (a) { try { i(a) } catch (u) { t.error(u) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } } function de(e, t) { return Oe((n, r) => { let i = 0; n.subscribe(Ne(r, o => { r.next(e.call(t, o, i++)) })) }) } function kn(e) { return this instanceof kn ? (this.v = e, this) : new kn(e) } function kv(e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var i, r = n.apply(e, t || []), o = []; return i = {}, s("next"), s("throw"), s("return"), i[Symbol.asyncIterator] = function () { return this }, i; function s(f) { r[f] && (i[f] = function (h) { return new Promise(function (p, m) { o.push([f, h, p, m]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function u(f) { f.value instanceof kn ? Promise.resolve(f.value.v).then(l, c) : d(o[0][2], f) }(r[f](h)) } catch (p) { d(o[0][3], p) } } function l(f) { a("next", f) } function c(f) { a("throw", f) } function d(f, h) { f(h), o.shift(), o.length && a(o[0][0], o[0][1]) } } function Lv(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, t = e[Symbol.asyncIterator]; return t ? t.call(e) : (e = function Uc(e) { var t = "function" == typeof Symbol && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(o) { n[o] = e[o] && function (s) { return new Promise(function (a, u) { !function i(o, s, a, u) { Promise.resolve(u).then(function (l) { o({ value: l, done: a }) }, s) }(a, u, (s = e[o](s)).done, s.value) }) } } } const $c = e => e && "number" == typeof e.length && "function" != typeof e; function zc(e) { return k(null == e ? void 0 : e.then) } function qc(e) { return k(e[Qs]) } function Gc(e) { return Symbol.asyncIterator && k(null == e ? void 0 : e[Symbol.asyncIterator]) } function Wc(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const Qc = function Bv() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function Zc(e) { return k(null == e ? void 0 : e[Qc]) } function Yc(e) { return kv(this, arguments, function* () { const n = e.getReader(); try { for (; ;) { const { value: r, done: i } = yield kn(n.read()); if (i) return yield kn(void 0); yield yield kn(r) } } finally { n.releaseLock() } }) } function Kc(e) { return k(null == e ? void 0 : e.getReader) } function en(e) { if (e instanceof Me) return e; if (null != e) { if (qc(e)) return function Vv(e) { return new Me(t => { const n = e[Qs](); if (k(n.subscribe)) return n.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if ($c(e)) return function Hv(e) { return new Me(t => { for (let n = 0; n < e.length && !t.closed; n++)t.next(e[n]); t.complete() }) }(e); if (zc(e)) return function Uv(e) { return new Me(t => { e.then(n => { t.closed || (t.next(n), t.complete()) }, n => t.error(n)).then(null, w) }) }(e); if (Gc(e)) return Jc(e); if (Zc(e)) return function $v(e) { return new Me(t => { for (const n of e) if (t.next(n), t.closed) return; t.complete() }) }(e); if (Kc(e)) return function zv(e) { return Jc(Yc(e)) }(e) } throw Wc(e) } function Jc(e) { return new Me(t => { (function qv(e, t) { var n, r, i, o; return function Nv(e, t, n, r) { return new (n || (n = Promise))(function (o, s) { function a(c) { try { l(r.next(c)) } catch (d) { s(d) } } function u(c) { try { l(r.throw(c)) } catch (d) { s(d) } } function l(c) { c.done ? o(c.value) : function i(o) { return o instanceof n ? o : new n(function (s) { s(o) }) }(c.value).then(a, u) } l((r = r.apply(e, t || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = Lv(e); !(r = yield n.next()).done;)if (t.next(r.value), t.closed) return } catch (s) { i = { error: s } } finally { try { r && !r.done && (o = n.return) && (yield o.call(n)) } finally { if (i) throw i.error } } t.complete() }) })(e, t).catch(n => t.error(n)) }) } function tn(e, t, n, r = 0, i = !1) { const o = t.schedule(function () { n(), i ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(o), !i) return o } function xe(e, t, n = 1 / 0) { return k(t) ? xe((r, i) => de((o, s) => t(r, o, i, s))(en(e(r, i))), n) : ("number" == typeof t && (n = t), Oe((r, i) => function Gv(e, t, n, r, i, o, s, a) { const u = []; let l = 0, c = 0, d = !1; const f = () => { d && !u.length && !l && t.complete() }, h = m => l < r ? p(m) : u.push(m), p = m => { o && t.next(m), l++; let C = !1; en(n(m, c++)).subscribe(Ne(t, _ => { null == i || i(_), o ? h(_) : t.next(_) }, () => { C = !0 }, void 0, () => { if (C) try { for (l--; u.length && l < r;) { const _ = u.shift(); s ? tn(t, s, () => p(_)) : p(_) } f() } catch (_) { t.error(_) } })) }; return e.subscribe(Ne(t, h, () => { d = !0, f() })), () => { null == a || a() } }(r, i, e, n))) } function Jr(e = 1 / 0) { return xe(Fn, e) } const nn = new Me(e => e.complete()); function Ys(e) { return e[e.length - 1] } function Xr(e) { return function Qv(e) { return e && k(e.schedule) }(Ys(e)) ? e.pop() : void 0 } function Xc(e, t = 0) { return Oe((n, r) => { n.subscribe(Ne(r, i => tn(r, e, () => r.next(i), t), () => tn(r, e, () => r.complete(), t), i => tn(r, e, () => r.error(i), t))) }) } function ed(e, t = 0) { return Oe((n, r) => { r.add(e.schedule(() => n.subscribe(r), t)) }) } function td(e, t) { if (!e) throw new Error("Iterable cannot be null"); return new Me(n => { tn(n, t, () => { const r = e[Symbol.asyncIterator](); tn(n, t, () => { r.next().then(i => { i.done ? n.complete() : n.next(i.value) }) }, 0, !0) }) }) } function Fe(e, t) { return t ? function nD(e, t) { if (null != e) { if (qc(e)) return function Kv(e, t) { return en(e).pipe(ed(t), Xc(t)) }(e, t); if ($c(e)) return function Xv(e, t) { return new Me(n => { let r = 0; return t.schedule(function () { r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule()) }) }) }(e, t); if (zc(e)) return function Jv(e, t) { return en(e).pipe(ed(t), Xc(t)) }(e, t); if (Gc(e)) return td(e, t); if (Zc(e)) return function eD(e, t) { return new Me(n => { let r; return tn(n, t, () => { r = e[Qc](), tn(n, t, () => { let i, o; try { ({ value: i, done: o } = r.next()) } catch (s) { return void n.error(s) } o ? n.complete() : n.next(i) }, 0, !0) }), () => k(null == r ? void 0 : r.return) && r.return() }) }(e, t); if (Kc(e)) return function tD(e, t) { return td(Yc(e), t) }(e, t) } throw Wc(e) }(e, t) : en(e) } function so(e) { return e <= 0 ? () => nn : Oe((t, n) => { let r = 0; t.subscribe(Ne(n, i => { ++r <= e && (n.next(i), e <= r && n.complete()) })) }) } function Ks(e, t, ...n) { return !0 === t ? (e(), null) : !1 === t ? null : t(...n).pipe(so(1)).subscribe(() => e()) } function te(e) { for (let t in e) if (e[t] === te) return t; throw Error("Could not find renamed property on target object.") } function J(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map(J).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const t = e.toString(); if (null == t) return "" + t; const n = t.indexOf("\n"); return -1 === n ? t : t.substring(0, n) } function Xs(e, t) { return null == e || "" === e ? null === t ? "" : t : null == t || "" === t ? e : e + " " + t } const oD = te({ __forward_ref__: te }); function ea(e) { return e.__forward_ref__ = ea, e.toString = function () { return J(this()) }, e } function L(e) { return function nd(e) { return "function" == typeof e && e.hasOwnProperty(oD) && e.__forward_ref__ === ea }(e) ? e() : e } class K extends Error { constructor(t, n) { super(function ta(e, t) { return `NG0${Math.abs(e)}${t ? ": " + t : ""}` }(t, n)), this.code = t } } function ke(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : function O(e) { return "string" == typeof e ? e : null == e ? "" : String(e) }(e) } function ao(e, t) { const n = t ? ` in ${t}` : ""; throw new K(-201, `No provider for ${ke(e)} found${n}`) } function ot(e, t) { null == e && function ne(e, t, n, r) { throw new Error(`ASSERTION ERROR: ${e}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${t} <=Actual]`)) }(t, e, null, "!=") } function W(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function on(e) { return { providers: e.providers || [], imports: e.imports || [] } } function na(e) { return rd(e, uo) || rd(e, od) } function rd(e, t) { return e.hasOwnProperty(t) ? e[t] : null } function id(e) { return e && (e.hasOwnProperty(ra) || e.hasOwnProperty(fD)) ? e[ra] : null } const uo = te({ \u0275prov: te }), ra = te({ \u0275inj: te }), od = te({ ngInjectableDef: te }), fD = te({ ngInjectorDef: te }); var P = (() => ((P = P || {})[P.Default = 0] = "Default", P[P.Host = 1] = "Host", P[P.Self = 2] = "Self", P[P.SkipSelf = 4] = "SkipSelf", P[P.Optional = 8] = "Optional", P))(); let ia; function vn(e) { const t = ia; return ia = e, t } function sd(e, t, n) { const r = na(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & P.Optional ? null : void 0 !== t ? t : void ao(J(e), "Injector") } function Dn(e) { return { toString: e }.toString() } var It = (() => ((It = It || {})[It.OnPush = 0] = "OnPush", It[It.Default = 1] = "Default", It))(), Bt = (() => { return (e = Bt || (Bt = {}))[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", Bt; var e })(); const pD = "undefined" != typeof globalThis && globalThis, gD = "undefined" != typeof window && window, mD = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, X = pD || "undefined" != typeof global && global || gD || mD, tr = {}, re = [], lo = te({ \u0275cmp: te }), oa = te({ \u0275dir: te }), sa = te({ \u0275pipe: te }), ad = te({ \u0275mod: te }), sn = te({ \u0275fac: te }), ei = te({ __NG_ELEMENT_ID__: te }); let yD = 0; function Vt(e) { return Dn(() => { const n = {}, r = { type: e.type, providersResolver: null, decls: e.decls, vars: e.vars, factory: null, template: e.template || null, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: n, inputs: null, outputs: null, exportAs: e.exportAs || null, onPush: e.changeDetection === It.OnPush, directiveDefs: null, pipeDefs: null, selectors: e.selectors || re, viewQuery: e.viewQuery || null, features: e.features || null, data: e.data || {}, encapsulation: e.encapsulation || Bt.Emulated, id: "c", styles: e.styles || re, _: null, setInput: null, schemas: e.schemas || null, tView: null }, i = e.directives, o = e.features, s = e.pipes; return r.id += yD++, r.inputs = dd(e.inputs, n), r.outputs = dd(e.outputs), o && o.forEach(a => a(r)), r.directiveDefs = i ? () => ("function" == typeof i ? i() : i).map(ud) : null, r.pipeDefs = s ? () => ("function" == typeof s ? s() : s).map(ld) : null, r }) } function ud(e) { return Ue(e) || function _n(e) { return e[oa] || null }(e) } function ld(e) { return function Ln(e) { return e[sa] || null }(e) } const cd = {}; function Cn(e) { return Dn(() => { const t = { type: e.type, bootstrap: e.bootstrap || re, declarations: e.declarations || re, imports: e.imports || re, exports: e.exports || re, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null }; return null != e.id && (cd[e.id] = e.type), t }) } function dd(e, t) { if (null == e) return tr; const n = {}; for (const r in e) if (e.hasOwnProperty(r)) { let i = e[r], o = i; Array.isArray(i) && (o = i[1], i = i[0]), n[i] = r, t && (t[i] = o) } return n } const He = Vt; function Ue(e) { return e[lo] || null } function mt(e, t) { const n = e[ad] || null; if (!n && !0 === t) throw new Error(`Type ${J(e)} does not have '\u0275mod' property.`); return n } const j = 11; function Ht(e) { return Array.isArray(e) && "object" == typeof e[1] } function St(e) { return Array.isArray(e) && !0 === e[1] } function la(e) { return 0 != (8 & e.flags) } function po(e) { return 2 == (2 & e.flags) } function go(e) { return 1 == (1 & e.flags) } function At(e) { return null !== e.template } function ED(e) { return 0 != (512 & e[2]) } function Hn(e, t) { return e.hasOwnProperty(sn) ? e[sn] : null } class ID { constructor(t, n, r) { this.previousValue = t, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function hd(e) { return e.type.prototype.ngOnChanges && (e.setInput = SD), TD } function TD() { const e = gd(this), t = null == e ? void 0 : e.current; if (t) { const n = e.previous; if (n === tr) e.previous = t; else for (let r in t) n[r] = t[r]; e.current = null, this.ngOnChanges(t) } } function SD(e, t, n, r) { const i = gd(e) || function AD(e, t) { return e[pd] = t }(e, { previous: tr, current: null }), o = i.current || (i.current = {}), s = i.previous, a = this.declaredInputs[n], u = s[a]; o[a] = new ID(u && u.currentValue, t, s === tr), e[r] = t } const pd = "__ngSimpleChanges__"; function gd(e) { return e[pd] || null } let pa; function ge(e) { return !!e.listen } const md = { createRenderer: (e, t) => function ga() { return void 0 !== pa ? pa : "undefined" != typeof document ? document : void 0 }() }; function Ce(e) { for (; Array.isArray(e);)e = e[0]; return e } function Dt(e, t) { return Ce(t[e.index]) } function at(e, t) { const n = t[e]; return Ht(n) ? n : n[0] } function yd(e) { return 4 == (4 & e[2]) } function ya(e) { return 128 == (128 & e[2]) } function wn(e, t) { return null == t ? null : e[t] } function vd(e) { e[18] = 0 } function va(e, t) { e[5] += t; let n = e, r = e[3]; for (; null !== r && (1 === t && 1 === n[5] || -1 === t && 0 === n[5]);)r[5] += t, n = r, r = r[3] } const N = { lFrame: Td(null), bindingsEnabled: !0 }; function Cd() { return N.bindingsEnabled } function v() { return N.lFrame.lView } function Q() { return N.lFrame.tView } function Ie() { let e = _d(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function _d() { return N.lFrame.currentTNode } function Ut(e, t) { const n = N.lFrame; n.currentTNode = e, n.isParent = t } function Da() { return N.lFrame.isParent } function WD(e, t) { const n = N.lFrame; n.bindingIndex = n.bindingRootIndex = e, _a(t) } function _a(e) { N.lFrame.currentDirectiveIndex = e } function bd() { return N.lFrame.currentQueryIndex } function Ea(e) { N.lFrame.currentQueryIndex = e } function ZD(e) { const t = e[1]; return 2 === t.type ? t.declTNode : 1 === t.type ? e[6] : null } function Md(e, t, n) { if (n & P.SkipSelf) { let i = t, o = e; for (; !(i = i.parent, null !== i || n & P.Host || (i = ZD(o), null === i || (o = o[15], 10 & i.type)));); if (null === i) return !1; t = i, e = o } const r = N.lFrame = Id(); return r.currentTNode = t, r.lView = e, !0 } function vo(e) { const t = Id(), n = e[1]; N.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function Id() { const e = N.lFrame, t = null === e ? null : e.child; return null === t ? Td(e) : t } function Td(e) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = t), t } function Sd() { const e = N.lFrame; return N.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const Ad = Sd; function Do() { const e = Sd(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function En(e) { N.lFrame.selectedIndex = e } function Co(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { const o = e.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: u, ngAfterViewChecked: l, ngOnDestroy: c } = o; s && (e.contentHooks || (e.contentHooks = [])).push(-n, s), a && ((e.contentHooks || (e.contentHooks = [])).push(n, a), (e.contentCheckHooks || (e.contentCheckHooks = [])).push(n, a)), u && (e.viewHooks || (e.viewHooks = [])).push(-n, u), l && ((e.viewHooks || (e.viewHooks = [])).push(n, l), (e.viewCheckHooks || (e.viewCheckHooks = [])).push(n, l)), null != c && (e.destroyHooks || (e.destroyHooks = [])).push(n, c) } } function _o(e, t, n) { xd(e, t, 3, n) } function wo(e, t, n, r) { (3 & e[2]) === n && xd(e, t, n, r) } function ba(e, t) { let n = e[2]; (3 & n) === t && (n &= 2047, n += 1, e[2] = n) } function xd(e, t, n, r) { const o = null != r ? r : -1, s = t.length - 1; let a = 0; for (let u = void 0 !== r ? 65535 & e[18] : 0; u < s; u++)if ("number" == typeof t[u + 1]) { if (a = t[u], null != r && a >= r) break } else t[u] < 0 && (e[18] += 65536), (a < o || -1 == o) && (iC(e, n, t, u), e[18] = (4294901760 & e[18]) + u + 2), u++ } function iC(e, t, n, r) { const i = n[r] < 0, o = n[r + 1], a = e[i ? -n[r] : n[r]]; if (i) { if (e[2] >> 11 < e[18] >> 16 && (3 & e[2]) === t) { e[2] += 2048; try { o.call(a) } finally { } } } else try { o.call(a) } finally { } } class oi { constructor(t, n, r) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function Eo(e, t, n) { const r = ge(e); let i = 0; for (; i < n.length;) { const o = n[i]; if ("number" == typeof o) { if (0 !== o) break; i++; const s = n[i++], a = n[i++], u = n[i++]; r ? e.setAttribute(t, a, u, s) : t.setAttributeNS(s, a, u) } else { const s = o, a = n[++i]; Ia(s) ? r && e.setProperty(t, s, a) : r ? e.setAttribute(t, s, a) : t.setAttribute(s, a), i++ } } return i } function Rd(e) { return 3 === e || 4 === e || 6 === e } function Ia(e) { return 64 === e.charCodeAt(0) } function bo(e, t) { if (null !== t && 0 !== t.length) if (null === e || 0 === e.length) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { const i = t[r]; "number" == typeof i ? n = i : 0 === n || Pd(e, n, i, null, -1 === n || 2 === n ? t[++r] : null) } } return e } function Pd(e, t, n, r, i) { let o = 0, s = e.length; if (-1 === t) s = -1; else for (; o < e.length;) { const a = e[o++]; if ("number" == typeof a) { if (a === t) { s = -1; break } if (a > t) { s = o - 1; break } } } for (; o < e.length;) { const a = e[o]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== i && (e[o + 1] = i)); if (r === e[o + 1]) return void (e[o + 2] = i) } o++, null !== r && o++, null !== i && o++ } -1 !== s && (e.splice(s, 0, t), o = s + 1), e.splice(o++, 0, n), null !== r && e.splice(o++, 0, r), null !== i && e.splice(o++, 0, i) } function Od(e) { return -1 !== e } function ur(e) { return 32767 & e } function lr(e, t) { let n = function lC(e) { return e >> 16 }(e), r = t; for (; n > 0;)r = r[15], n--; return r } let Ta = !0; function Mo(e) { const t = Ta; return Ta = e, t } let cC = 0; function ai(e, t) { const n = Aa(e, t); if (-1 !== n) return n; const r = t[1]; r.firstCreatePass && (e.injectorIndex = t.length, Sa(r.data, e), Sa(t, null), Sa(r.blueprint, null)); const i = Io(e, t), o = e.injectorIndex; if (Od(i)) { const s = ur(i), a = lr(i, t), u = a[1].data; for (let l = 0; l < 8; l++)t[o + l] = a[s + l] | u[s + l] } return t[o + 8] = i, o } function Sa(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function Aa(e, t) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === t[e.injectorIndex + 8] ? -1 : e.injectorIndex } function Io(e, t) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let n = 0, r = null, i = t; for (; null !== i;) { const o = i[1], s = o.type; if (r = 2 === s ? o.declTNode : 1 === s ? i[6] : null, null === r) return -1; if (n++, i = i[15], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return -1 } function To(e, t, n) { !function dC(e, t, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(ei) && (r = n[ei]), null == r && (r = n[ei] = cC++); const i = 255 & r; t.data[e + (i >> 5)] |= 1 << i }(e, t, n) } function kd(e, t, n) { if (n & P.Optional) return e; ao(t, "NodeInjector") } function Ld(e, t, n, r) { if (n & P.Optional && void 0 === r && (r = null), 0 == (n & (P.Self | P.Host))) { const i = e[9], o = vn(void 0); try { return i ? i.get(t, r, n & P.Optional) : sd(t, r, n & P.Optional) } finally { vn(o) } } return kd(r, t, n) } function jd(e, t, n, r = P.Default, i) { if (null !== e) { const o = function gC(e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const t = e.hasOwnProperty(ei) ? e[ei] : void 0; return "number" == typeof t ? t >= 0 ? 255 & t : hC : t }(n); if ("function" == typeof o) { if (!Md(t, e, r)) return r & P.Host ? kd(i, n, r) : Ld(t, n, r, i); try { const s = o(r); if (null != s || r & P.Optional) return s; ao(n) } finally { Ad() } } else if ("number" == typeof o) { let s = null, a = Aa(e, t), u = -1, l = r & P.Host ? t[16][6] : null; for ((-1 === a || r & P.SkipSelf) && (u = -1 === a ? Io(e, t) : t[a + 8], -1 !== u && Hd(r, !1) ? (s = t[1], a = ur(u), t = lr(u, t)) : a = -1); -1 !== a;) { const c = t[1]; if (Vd(o, a, c.data)) { const d = pC(a, t, n, s, r, l); if (d !== Bd) return d } u = t[a + 8], -1 !== u && Hd(r, t[1].data[a + 8] === l) && Vd(o, a, t) ? (s = c, a = ur(u), t = lr(u, t)) : a = -1 } } } return Ld(t, n, r, i) } const Bd = {}; function hC() { return new cr(Ie(), v()) } function pC(e, t, n, r, i, o) { const s = t[1], a = s.data[e + 8], c = So(a, s, n, null == r ? po(a) && Ta : r != s && 0 != (3 & a.type), i & P.Host && o === a); return null !== c ? ui(t, s, c, a) : Bd } function So(e, t, n, r, i) { const o = e.providerIndexes, s = t.data, a = 1048575 & o, u = e.directiveStart, c = o >> 20, f = i ? a + c : e.directiveEnd; for (let h = r ? a : a + c; h < f; h++) { const p = s[h]; if (h < u && n === p || h >= u && p.type === n) return h } if (i) { const h = s[u]; if (h && At(h) && h.type === n) return u } return null } function ui(e, t, n, r) { let i = e[n]; const o = t.data; if (function oC(e) { return e instanceof oi }(i)) { const s = i; s.resolving && function sD(e, t) { const n = t ? `. Dependency path: ${t.join(" > ")} > ${e}` : ""; throw new K(-200, `Circular dependency in DI detected for ${e}${n}`) }(ke(o[n])); const a = Mo(s.canSeeViewProviders); s.resolving = !0; const u = s.injectImpl ? vn(s.injectImpl) : null; Md(e, r, P.Default); try { i = e[n] = s.factory(void 0, o, e, r), t.firstCreatePass && n >= r.directiveStart && function rC(e, t, n) { const { ngOnChanges: r, ngOnInit: i, ngDoCheck: o } = t.type.prototype; if (r) { const s = hd(t); (n.preOrderHooks || (n.preOrderHooks = [])).push(e, s), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, s) } i && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - e, i), o && ((n.preOrderHooks || (n.preOrderHooks = [])).push(e, o), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, o)) }(n, o[n], t) } finally { null !== u && vn(u), Mo(a), s.resolving = !1, Ad() } } return i } function Vd(e, t, n) { return !!(n[t + (e >> 5)] & 1 << e) } function Hd(e, t) { return !(e & P.Self || e & P.Host && t) } class cr { constructor(t, n) { this._tNode = t, this._lView = n } get(t, n, r) { return jd(this._tNode, this._lView, t, r, n) } } const fr = "__parameters__"; function pr(e, t, n) { return Dn(() => { const r = function Ra(e) { return function (...n) { if (e) { const r = e(...n); for (const i in r) this[i] = r[i] } } }(t); function i(...o) { if (this instanceof i) return r.apply(this, o), this; const s = new i(...o); return a.annotation = s, a; function a(u, l, c) { const d = u.hasOwnProperty(fr) ? u[fr] : Object.defineProperty(u, fr, { value: [] })[fr]; for (; d.length <= c;)d.push(null); return (d[c] = d[c] || []).push(s), u } } return n && (i.prototype = Object.create(n.prototype)), i.prototype.ngMetadataName = e, i.annotationCls = i, i }) } class Z { constructor(t, n) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = W({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } toString() { return `InjectionToken ${this._desc}` } } const vC = new Z("AnalyzeForEntryComponents"); function Ct(e, t) { void 0 === t && (t = e); for (let n = 0; n < e.length; n++) { let r = e[n]; Array.isArray(r) ? (t === e && (t = e.slice(0, n)), Ct(r, t)) : t !== e && t.push(r) } return t } function $t(e, t) { e.forEach(n => Array.isArray(n) ? $t(n, t) : t(n)) } function $d(e, t, n) { t >= e.length ? e.push(n) : e.splice(t, 0, n) } function Ao(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } const hi = {}, Fa = "__NG_DI_FLAG__", Ro = "ngTempTokenPath", SC = /\n/gm, Qd = "__source", xC = te({ provide: String, useValue: te }); let pi; function Zd(e) { const t = pi; return pi = e, t } function RC(e, t = P.Default) { if (void 0 === pi) throw new K(203, ""); return null === pi ? sd(e, void 0, t) : pi.get(e, t & P.Optional ? null : void 0, t) } function R(e, t = P.Default) { return (function hD() { return ia }() || RC)(L(e), t) } const PC = R; function ka(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = L(e[n]); if (Array.isArray(r)) { if (0 === r.length) throw new K(900, ""); let i, o = P.Default; for (let s = 0; s < r.length; s++) { const a = r[s], u = OC(a); "number" == typeof u ? -1 === u ? i = a.token : o |= u : i = a } t.push(R(i, o)) } else t.push(R(r)) } return t } function gi(e, t) { return e[Fa] = t, e.prototype[Fa] = t, e } function OC(e) { return e[Fa] } const Po = gi(pr("Inject", e => ({ token: e })), -1), Mn = gi(pr("Optional"), 8), mi = gi(pr("SkipSelf"), 4), gf = "__ngContext__"; function ze(e, t) { e[gf] = t } function Ga(e) { const t = function _i(e) { return e[gf] || null }(e); return t ? Array.isArray(t) ? t : t.lView : null } function Qa(e) { return e.ngOriginalError } function M_(e, ...t) { e.error(...t) } class wi { constructor() { this._console = console } handleError(t) { const n = this._findOriginalError(t), r = function b_(e) { return e && e.ngErrorLogger || M_ }(t); r(this._console, "ERROR", t), n && r(this._console, "ORIGINAL ERROR", n) } _findOriginalError(t) { let n = t && Qa(t); for (; n && Qa(n);)n = Qa(n); return n || null } } const F_ = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(X))(); function qt(e) { return e instanceof Function ? e() : e } var lt = (() => ((lt = lt || {})[lt.Important = 1] = "Important", lt[lt.DashCase = 2] = "DashCase", lt))(); function Ya(e, t) { return undefined(e, t) } function Ei(e) { const t = e[3]; return St(t) ? t[3] : t } function Ka(e) { return bf(e[13]) } function Ja(e) { return bf(e[4]) } function bf(e) { for (; null !== e && !St(e);)e = e[4]; return e } function Dr(e, t, n, r, i) { if (null != r) { let o, s = !1; St(r) ? o = r : Ht(r) && (s = !0, r = r[0]); const a = Ce(r); 0 === e && null !== n ? null == i ? xf(t, n, a) : $n(t, n, a, i || null, !0) : 1 === e && null !== n ? $n(t, n, a, i || null, !0) : 2 === e ? function Lf(e, t, n) { const r = jo(e, t); r && function Z_(e, t, n, r) { ge(e) ? e.removeChild(t, n, r) : t.removeChild(n) }(e, r, t, n) }(t, a, s) : 3 === e && t.destroyNode(a), null != o && function J_(e, t, n, r, i) { const o = n[7]; o !== Ce(n) && Dr(t, e, r, o, i); for (let a = 10; a < n.length; a++) { const u = n[a]; bi(u[1], u, e, t, r, o) } }(t, e, o, n, i) } } function eu(e, t, n) { if (ge(e)) return e.createElement(t, n); { const r = null !== n ? function OD(e) { const t = e.toLowerCase(); return "svg" === t ? "http://www.w3.org/2000/svg" : "math" === t ? "http://www.w3.org/1998/MathML/" : null }(n) : null; return null === r ? e.createElement(t) : e.createElementNS(r, t) } } function If(e, t) { const n = e[9], r = n.indexOf(t), i = t[3]; 1024 & t[2] && (t[2] &= -1025, va(i, -1)), n.splice(r, 1) } function tu(e, t) { if (e.length <= 10) return; const n = 10 + t, r = e[n]; if (r) { const i = r[17]; null !== i && i !== e && If(i, r), t > 0 && (e[n - 1][4] = r[4]); const o = Ao(e, 10 + t); !function H_(e, t) { bi(e, t, t[j], 2, null, null), t[0] = null, t[6] = null }(r[1], r); const s = o[19]; null !== s && s.detachView(o[1]), r[3] = null, r[4] = null, r[2] &= -129 } return r } function Tf(e, t) { if (!(256 & t[2])) { const n = t[j]; ge(n) && n.destroyNode && bi(e, t, n, 3, null, null), function z_(e) { let t = e[13]; if (!t) return nu(e[1], e); for (; t;) { let n = null; if (Ht(t)) n = t[13]; else { const r = t[10]; r && (n = r) } if (!n) { for (; t && !t[4] && t !== e;)Ht(t) && nu(t[1], t), t = t[3]; null === t && (t = e), Ht(t) && nu(t[1], t), n = t && t[4] } t = n } }(t) } } function nu(e, t) { if (!(256 & t[2])) { t[2] &= -129, t[2] |= 256, function Q_(e, t) { let n; if (null != e && null != (n = e.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const i = t[n[r]]; if (!(i instanceof oi)) { const o = n[r + 1]; if (Array.isArray(o)) for (let s = 0; s < o.length; s += 2) { const a = i[o[s]], u = o[s + 1]; try { u.call(a) } finally { } } else try { o.call(i) } finally { } } } }(e, t), function W_(e, t) { const n = e.cleanup, r = t[7]; let i = -1; if (null !== n) for (let o = 0; o < n.length - 1; o += 2)if ("string" == typeof n[o]) { const s = n[o + 1], a = "function" == typeof s ? s(t) : Ce(t[s]), u = r[i = n[o + 2]], l = n[o + 3]; "boolean" == typeof l ? a.removeEventListener(n[o], u, l) : l >= 0 ? r[i = l]() : r[i = -l].unsubscribe(), o += 2 } else { const s = r[i = n[o + 1]]; n[o].call(s) } if (null !== r) { for (let o = i + 1; o < r.length; o++)r[o](); t[7] = null } }(e, t), 1 === t[1].type && ge(t[j]) && t[j].destroy(); const n = t[17]; if (null !== n && St(t[3])) { n !== t[3] && If(n, t); const r = t[19]; null !== r && r.detachView(e) } } } function Sf(e, t, n) { return function Af(e, t, n) { let r = t; for (; null !== r && 40 & r.type;)r = (t = r).parent; if (null === r) return n[0]; if (2 & r.flags) { const i = e.data[r.directiveStart].encapsulation; if (i === Bt.None || i === Bt.Emulated) return null } return Dt(r, n) }(e, t.parent, n) } function $n(e, t, n, r, i) { ge(e) ? e.insertBefore(t, n, r, i) : t.insertBefore(n, r, i) } function xf(e, t, n) { ge(e) ? e.appendChild(t, n) : t.appendChild(n) } function Rf(e, t, n, r, i) { null !== r ? $n(e, t, n, r, i) : xf(e, t, n) } function jo(e, t) { return ge(e) ? e.parentNode(t) : t.parentNode } let Nf = function Of(e, t, n) { return 40 & e.type ? Dt(e, n) : null }; function Bo(e, t, n, r) { const i = Sf(e, r, t), o = t[j], a = function Pf(e, t, n) { return Nf(e, t, n) }(r.parent || t[6], r, t); if (null != i) if (Array.isArray(n)) for (let u = 0; u < n.length; u++)Rf(o, i, n[u], a, !1); else Rf(o, i, n, a, !1) } function Vo(e, t) { if (null !== t) { const n = t.type; if (3 & n) return Dt(t, e); if (4 & n) return iu(-1, e[t.index]); if (8 & n) { const r = t.child; if (null !== r) return Vo(e, r); { const i = e[t.index]; return St(i) ? iu(-1, i) : Ce(i) } } if (32 & n) return Ya(t, e)() || Ce(e[t.index]); { const r = kf(e, t); return null !== r ? Array.isArray(r) ? r[0] : Vo(Ei(e[16]), r) : Vo(e, t.next) } } return null } function kf(e, t) { return null !== t ? e[16][6].projection[t.projection] : null } function iu(e, t) { const n = 10 + e + 1; if (n < t.length) { const r = t[n], i = r[1].firstChild; if (null !== i) return Vo(r, i) } return t[7] } function ou(e, t, n, r, i, o, s) { for (; null != n;) { const a = r[n.index], u = n.type; if (s && 0 === t && (a && ze(Ce(a), r), n.flags |= 4), 64 != (64 & n.flags)) if (8 & u) ou(e, t, n.child, r, i, o, !1), Dr(t, e, i, a, o); else if (32 & u) { const l = Ya(n, r); let c; for (; c = l();)Dr(t, e, i, c, o); Dr(t, e, i, a, o) } else 16 & u ? jf(e, t, r, n, i, o) : Dr(t, e, i, a, o); n = s ? n.projectionNext : n.next } } function bi(e, t, n, r, i, o) { ou(n, r, e.firstChild, t, i, o, !1) } function jf(e, t, n, r, i, o) { const s = n[16], u = s[6].projection[r.projection]; if (Array.isArray(u)) for (let l = 0; l < u.length; l++)Dr(t, e, i, u[l], o); else ou(e, t, u, s[3], i, o, !0) } function Bf(e, t, n) { ge(e) ? e.setAttribute(t, "style", n) : t.style.cssText = n } function su(e, t, n) { ge(e) ? "" === n ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) : t.className = n } function Vf(e, t, n) { let r = e.length; for (; ;) { const i = e.indexOf(t, n); if (-1 === i) return i; if (0 === i || e.charCodeAt(i - 1) <= 32) { const o = t.length; if (i + o === r || e.charCodeAt(i + o) <= 32) return i } n = i + 1 } } const Hf = "ng-template"; function ew(e, t, n) { let r = 0; for (; r < e.length;) { let i = e[r++]; if (n && "class" === i) { if (i = e[r], -1 !== Vf(i.toLowerCase(), t, 0)) return !0 } else if (1 === i) { for (; r < e.length && "string" == typeof (i = e[r++]);)if (i.toLowerCase() === t) return !0; return !1 } } return !1 } function Uf(e) { return 4 === e.type && e.value !== Hf } function tw(e, t, n) { return t === (4 !== e.type || n ? e.value : Hf) } function nw(e, t, n) { let r = 4; const i = e.attrs || [], o = function ow(e) { for (let t = 0; t < e.length; t++)if (Rd(e[t])) return t; return e.length }(i); let s = !1; for (let a = 0; a < t.length; a++) { const u = t[a]; if ("number" != typeof u) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== u && !tw(e, u, n) || "" === u && 1 === t.length) { if (xt(r)) return !1; s = !0 } } else { const l = 8 & r ? u : t[++a]; if (8 & r && null !== e.attrs) { if (!ew(e.attrs, l, n)) { if (xt(r)) return !1; s = !0 } continue } const d = rw(8 & r ? "class" : u, i, Uf(e), n); if (-1 === d) { if (xt(r)) return !1; s = !0; continue } if ("" !== l) { let f; f = d > o ? "" : i[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== Vf(h, l, 0) || 2 & r && l !== f) { if (xt(r)) return !1; s = !0 } } } } else { if (!s && !xt(r) && !xt(u)) return !1; if (s && xt(u)) continue; s = !1, r = u | 1 & r } } return xt(r) || s } function xt(e) { return 0 == (1 & e) } function rw(e, t, n, r) { if (null === t) return -1; let i = 0; if (r || !n) { let o = !1; for (; i < t.length;) { const s = t[i]; if (s === e) return i; if (3 === s || 6 === s) o = !0; else { if (1 === s || 2 === s) { let a = t[++i]; for (; "string" == typeof a;)a = t[++i]; continue } if (4 === s) break; if (0 === s) { i += 4; continue } } i += o ? 1 : 2 } return -1 } return function sw(e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { const r = e[n]; if ("number" == typeof r) return -1; if (r === t) return n; n++ } return -1 }(t, e) } function $f(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (nw(e, t[r], n)) return !0; return !1 } function zf(e, t) { return e ? ":not(" + t.trim() + ")" : t } function uw(e) { let t = e[0], n = 1, r = 2, i = "", o = !1; for (; n < e.length;) { let s = e[n]; if ("string" == typeof s) if (2 & r) { const a = e[++n]; i += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? i += "." + s : 4 & r && (i += " " + s); else "" !== i && !xt(s) && (t += zf(o, i), i = ""), r = s, o = o || !xt(r); n++ } return "" !== i && (t += zf(o, i)), t } const F = {}; function nh(e, t) { const n = e.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const i = n[r], o = n[r + 1]; if (-1 !== o) { const s = e.data[o]; Ea(i), s.contentQueries(2, t[o], o) } } } function Mi(e, t, n, r, i, o, s, a, u, l) { const c = t.blueprint.slice(); return c[0] = i, c[2] = 140 | r, vd(c), c[3] = c[15] = e, c[8] = n, c[10] = s || e && e[10], c[j] = a || e && e[j], c[12] = u || e && e[12] || null, c[9] = l || e && e[9] || null, c[6] = o, c[16] = 2 == t.type ? e[16] : c, c } function Cr(e, t, n, r, i) { let o = e.data[t]; if (null === o) o = function vu(e, t, n, r, i) { const o = _d(), s = Da(), u = e.data[t] = function Tw(e, t, n, r, i, o) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: t ? t.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: i, attrs: o, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? o : o && o.parent, n, t, r, i); return null === e.firstChild && (e.firstChild = u), null !== o && (s ? null == o.child && null !== u.parent && (o.child = u) : null === o.next && (o.next = u)), u }(e, t, n, r, i), function GD() { return N.lFrame.inI18n }() && (o.flags |= 64); else if (64 & o.type) { o.type = n, o.value = r, o.attrs = i; const s = function ii() { const e = N.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent }(); o.injectorIndex = null === s ? -1 : s.injectorIndex } return Ut(o, !0), o } function _r(e, t, n, r) { if (0 === n) return -1; const i = t.length; for (let o = 0; o < n; o++)t.push(r), e.blueprint.push(r), e.data.push(null); return i } function Ii(e, t, n) { vo(t); try { const r = e.viewQuery; null !== r && Tu(1, r, n); const i = e.template; null !== i && rh(e, t, i, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && nh(e, t), e.staticViewQueries && Tu(2, e.viewQuery, n); const o = e.components; null !== o && function bw(e, t) { for (let n = 0; n < t.length; n++)qw(e, t[n]) }(t, o) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { t[2] &= -5, Do() } } function wr(e, t, n, r) { const i = t[2]; if (256 != (256 & i)) { vo(t); try { vd(t), function wd(e) { return N.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== n && rh(e, t, n, 2, r); const s = 3 == (3 & i); if (s) { const l = e.preOrderCheckHooks; null !== l && _o(t, l, null) } else { const l = e.preOrderHooks; null !== l && wo(t, l, 0, null), ba(t, 0) } if (function $w(e) { for (let t = Ka(e); null !== t; t = Ja(t)) { if (!t[2]) continue; const n = t[9]; for (let r = 0; r < n.length; r++) { const i = n[r], o = i[3]; 0 == (1024 & i[2]) && va(o, 1), i[2] |= 1024 } } }(t), function Uw(e) { for (let t = Ka(e); null !== t; t = Ja(t))for (let n = 10; n < t.length; n++) { const r = t[n], i = r[1]; ya(r) && wr(i, r, i.template, r[8]) } }(t), null !== e.contentQueries && nh(e, t), s) { const l = e.contentCheckHooks; null !== l && _o(t, l) } else { const l = e.contentHooks; null !== l && wo(t, l, 1), ba(t, 1) } !function ww(e, t) { const n = e.hostBindingOpCodes; if (null !== n) try { for (let r = 0; r < n.length; r++) { const i = n[r]; if (i < 0) En(~i); else { const o = i, s = n[++r], a = n[++r]; WD(s, o), a(2, t[o]) } } } finally { En(-1) } }(e, t); const a = e.components; null !== a && function Ew(e, t) { for (let n = 0; n < t.length; n++)zw(e, t[n]) }(t, a); const u = e.viewQuery; if (null !== u && Tu(2, u, r), s) { const l = e.viewCheckHooks; null !== l && _o(t, l) } else { const l = e.viewHooks; null !== l && wo(t, l, 2), ba(t, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), t[2] &= -73, 1024 & t[2] && (t[2] &= -1025, va(t[3], -1)) } finally { Do() } } } function Mw(e, t, n, r) { const i = t[10], s = yd(t); try { !s && i.begin && i.begin(), s && Ii(e, t, r), wr(e, t, n, r) } finally { !s && i.end && i.end() } } function rh(e, t, n, r, i) { const o = function Qe() { return N.lFrame.selectedIndex }(), s = 2 & r; try { En(-1), s && t.length > 20 && function qf(e, t, n, r) { if (!r) if (3 == (3 & t[2])) { const o = e.preOrderCheckHooks; null !== o && _o(t, o, n) } else { const o = e.preOrderHooks; null !== o && wo(t, o, 0, n) } En(n) }(e, t, 20, !1), n(r, i) } finally { En(o) } } function oh(e) { const t = e.tView; return null === t || t.incompleteFirstPass ? e.tView = zo(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts) : t } function zo(e, t, n, r, i, o, s, a, u, l) { const c = 20 + r, d = c + i, f = function Iw(e, t) { const n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : F); return n }(c, d), h = "function" == typeof l ? l() : l; return f[1] = { type: e, blueprint: f, template: n, queries: null, viewQuery: a, declTNode: t, data: f.slice().fill(null, c), bindingStartIndex: c, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof o ? o() : o, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: u, consts: h, incompleteFirstPass: !1 } } function uh(e, t, n, r) { const i = vh(t); null === n ? i.push(r) : (i.push(n), e.firstCreatePass && Dh(e).push(r, i.length - 1)) } function lh(e, t, n) { for (let r in e) if (e.hasOwnProperty(r)) { const i = e[r]; (n = null === n ? {} : n).hasOwnProperty(r) ? n[r].push(t, i) : n[r] = [t, i] } return n } function dh(e, t, n, r, i, o) { const s = o.hostBindings; if (s) { let a = e.hostBindingOpCodes; null === a && (a = e.hostBindingOpCodes = []); const u = ~t.index; (function Ow(e) { let t = e.length; for (; t > 0;) { const n = e[--t]; if ("number" == typeof n && n < 0) return n } return 0 })(a) != u && a.push(u), a.push(r, i, s) } } function fh(e, t) { null !== e.hostBindings && e.hostBindings(1, t) } function hh(e, t) { t.flags |= 2, (e.components || (e.components = [])).push(t.index) } function jw(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; At(t) && (n[""] = e) } } function ph(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t } function gh(e, t, n, r, i) { e.data[r] = i; const o = i.factory || (i.factory = Hn(i.type)), s = new oi(o, At(i), null); e.blueprint[r] = s, n[r] = s, dh(e, t, 0, r, _r(e, n, i.hostVars, F), i) } function Bw(e, t, n) { const r = Dt(t, e), i = oh(n), o = e[10], s = qo(e, Mi(e, i, null, n.onPush ? 64 : 16, r, t, o, o.createRenderer(r, n), null, null)); e[t.index] = s } function Vw(e, t, n, r, i, o) { const s = o[t]; if (null !== s) { const a = r.setInput; for (let u = 0; u < s.length;) { const l = s[u++], c = s[u++], d = s[u++]; null !== a ? r.setInput(n, d, l, c) : n[c] = d } } } function Hw(e, t) { let n = null, r = 0; for (; r < t.length;) { const i = t[r]; if (0 !== i) if (5 !== i) { if ("number" == typeof i) break; e.hasOwnProperty(i) && (null === n && (n = []), n.push(i, e[i], t[r + 1])), r += 2 } else r += 2; else r += 4 } return n } function zw(e, t) { const n = at(t, e); if (ya(n)) { const r = n[1]; 80 & n[2] ? wr(r, n, r.template, n[8]) : n[5] > 0 && Eu(n) } } function Eu(e) { for (let r = Ka(e); null !== r; r = Ja(r))for (let i = 10; i < r.length; i++) { const o = r[i]; if (1024 & o[2]) { const s = o[1]; wr(s, o, s.template, o[8]) } else o[5] > 0 && Eu(o) } const n = e[1].components; if (null !== n) for (let r = 0; r < n.length; r++) { const i = at(n[r], e); ya(i) && i[5] > 0 && Eu(i) } } function qw(e, t) { const n = at(t, e), r = n[1]; (function Gw(e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) })(r, n), Ii(r, n, n[8]) } function qo(e, t) { return e[13] ? e[14][4] = t : e[13] = t, e[14] = t, t } function bu(e) { for (; e;) { e[2] |= 64; const t = Ei(e); if (ED(e) && !t) return e; e = t } return null } function yh(e) { !function Mu(e) { for (let t = 0; t < e.components.length; t++) { const n = e.components[t], r = Ga(n), i = r[1]; Mw(i, r, i.template, n) } }(e[8]) } function Tu(e, t, n) { Ea(0), t(e, n) } const Qw = (() => Promise.resolve(null))(); function vh(e) { return e[7] || (e[7] = []) } function Dh(e) { return e.cleanup || (e.cleanup = []) } function _h(e, t) { const n = e[9], r = n ? n.get(wi, null) : null; r && r.handleError(t) } function Go(e, t, n) { let r = n ? e.styles : null, i = n ? e.classes : null, o = 0; if (null !== t) for (let s = 0; s < t.length; s++) { const a = t[s]; "number" == typeof a ? o = a : 1 == o ? i = Xs(i, a) : 2 == o && (r = Xs(r, a + ": " + t[++s] + ";")) } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = i : e.classesWithoutHost = i } const Su = new Z("INJECTOR", -1); class Eh { get(t, n = hi) { if (n === hi) { const r = new Error(`NullInjectorError: No provider for ${J(t)}!`); throw r.name = "NullInjectorError", r } return n } } const Au = new Z("Set Injector scope."), Ti = {}, Kw = {}; let xu; function bh() { return void 0 === xu && (xu = new Eh), xu } function Mh(e, t = null, n = null, r) { const i = Ih(e, t, n, r); return i._resolveInjectorDefTypes(), i } function Ih(e, t = null, n = null, r) { return new Jw(e, n, t || bh(), r) } class Jw { constructor(t, n, r, i = null) { this.parent = r, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const o = []; n && $t(n, a => this.processProvider(a, t, n)), $t([t], a => this.processInjectorType(a, [], o)), this.records.set(Su, Er(void 0, this)); const s = this.records.get(Au); this.scope = null != s ? s.value : null, this.source = i || ("object" == typeof t ? null : J(t)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(t => t.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(t, n = hi, r = P.Default) { this.assertNotDestroyed(); const i = Zd(this), o = vn(void 0); try { if (!(r & P.SkipSelf)) { let a = this.records.get(t); if (void 0 === a) { const u = function sE(e) { return "function" == typeof e || "object" == typeof e && e instanceof Z }(t) && na(t); a = u && this.injectableDefInScope(u) ? Er(Ru(t), Ti) : null, this.records.set(t, a) } if (null != a) return this.hydrate(t, a) } return (r & P.Self ? bh() : this.parent).get(t, n = r & P.Optional && n === hi ? null : n) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[Ro] = s[Ro] || []).unshift(J(t)), i) throw s; return function NC(e, t, n, r) { const i = e[Ro]; throw t[Qd] && i.unshift(t[Qd]), e.message = function FC(e, t, n, r = null) { e = e && "\n" === e.charAt(0) && "\u0275" == e.charAt(1) ? e.substr(2) : e; let i = J(t); if (Array.isArray(t)) i = t.map(J).join(" -> "); else if ("object" == typeof t) { let o = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; o.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : J(a))) } i = `{${o.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${i}]: ${e.replace(SC, "\n  ")}` }("\n" + e.message, i, n, r), e.ngTokenPath = i, e[Ro] = null, e }(s, t, "R3InjectorError", this.source) } throw s } finally { vn(o), Zd(i) } } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(t => this.get(t)) } toString() { const t = []; return this.records.forEach((r, i) => t.push(J(i))), `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new K(205, !1) } processInjectorType(t, n, r) { if (!(t = L(t))) return !1; let i = id(t); const o = null == i && t.ngModule || void 0, s = void 0 === o ? t : o, a = -1 !== r.indexOf(s); if (void 0 !== o && (i = id(o)), null == i) return !1; if (null != i.imports && !a) { let c; r.push(s); try { $t(i.imports, d => { this.processInjectorType(d, n, r) && (void 0 === c && (c = []), c.push(d)) }) } finally { } if (void 0 !== c) for (let d = 0; d < c.length; d++) { const { ngModule: f, providers: h } = c[d]; $t(h, p => this.processProvider(p, f, h || re)) } } this.injectorDefTypes.add(s); const u = Hn(s) || (() => new s); this.records.set(s, Er(u, Ti)); const l = i.providers; if (null != l && !a) { const c = t; $t(l, d => this.processProvider(d, c, l)) } return void 0 !== o && void 0 !== t.providers } processProvider(t, n, r) { let i = br(t = L(t)) ? t : L(t && t.provide); const o = function eE(e, t, n) { return Sh(e) ? Er(void 0, e.useValue) : Er(function Th(e, t, n) { let r; if (br(e)) { const i = L(e); return Hn(i) || Ru(i) } if (Sh(e)) r = () => L(e.useValue); else if (function nE(e) { return !(!e || !e.useFactory) }(e)) r = () => e.useFactory(...ka(e.deps || [])); else if (function tE(e) { return !(!e || !e.useExisting) }(e)) r = () => R(L(e.useExisting)); else { const i = L(e && (e.useClass || e.provide)); if (!function iE(e) { return !!e.deps }(e)) return Hn(i) || Ru(i); r = () => new i(...ka(e.deps)) } return r }(e), Ti) }(t); if (br(t) || !0 !== t.multi) this.records.get(i); else { let s = this.records.get(i); s || (s = Er(void 0, Ti, !0), s.factory = () => ka(s.multi), this.records.set(i, s)), i = t, s.multi.push(t) } this.records.set(i, o) } hydrate(t, n) { return n.value === Ti && (n.value = Kw, n.value = n.factory()), "object" == typeof n.value && n.value && function oE(e) { return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy }(n.value) && this.onDestroy.add(n.value), n.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const n = L(t.providedIn); return "string" == typeof n ? "any" === n || n === this.scope : this.injectorDefTypes.has(n) } } function Ru(e) { const t = na(e), n = null !== t ? t.factory : Hn(e); if (null !== n) return n; if (e instanceof Z) throw new K(204, !1); if (e instanceof Function) return function Xw(e) { const t = e.length; if (t > 0) throw function fi(e, t) { const n = []; for (let r = 0; r < e; r++)n.push(t); return n }(t, "?"), new K(204, !1); const n = function cD(e) { const t = e && (e[uo] || e[od]); if (t) { const n = function dD(e) { if (e.hasOwnProperty("name")) return e.name; const t = ("" + e).match(/^function\s*([^\s(]+)/); return null === t ? "" : t[1] }(e); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), t } return null }(e); return null !== n ? () => n.factory(e) : () => new e }(e); throw new K(204, !1) } function Er(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function Sh(e) { return null !== e && "object" == typeof e && xC in e } function br(e) { return "function" == typeof e } let dt = (() => { class e { static create(n, r) { var i; if (Array.isArray(n)) return Mh({ name: "" }, r, n, ""); { const o = null !== (i = n.name) && void 0 !== i ? i : ""; return Mh({ name: o }, n.parent, n.providers, o) } } } return e.THROW_IF_NOT_FOUND = hi, e.NULL = new Eh, e.\u0275prov = W({ token: e, providedIn: "any", factory: () => R(Su) }), e.__NG_ELEMENT_ID__ = -1, e })(); function pE(e, t) { Co(Ga(e)[1], Ie()) } let Wo = null; function Mr() { if (!Wo) { const e = X.Symbol; if (e && e.iterator) Wo = e.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let n = 0; n < t.length; ++n) { const r = t[n]; "entries" !== r && "size" !== r && Map.prototype[r] === Map.prototype.entries && (Wo = r) } } } return Wo } function S(e, t = P.Default) { const n = v(); return null === n ? R(e, t) : jd(Ie(), n, L(e), t) } function Hu() { throw new Error("invalid") } function Uu(e, t, n, r, i) { const s = i ? "class" : "style"; !function wh(e, t, n, r, i) { for (let o = 0; o < n.length;) { const s = n[o++], a = n[o++], u = t[s], l = e.data[s]; null !== l.setInput ? l.setInput(u, i, r, a) : u[a] = i } }(e, n, t.inputs[s], s, r) } function he(e, t, n, r) { const i = v(), o = Q(), s = 20 + e, a = i[j], u = i[s] = eu(a, t, function nC() { return N.lFrame.currentNamespace }()), l = o.firstCreatePass ? function QE(e, t, n, r, i, o, s) { const a = t.consts, l = Cr(t, e, 2, i, wn(a, o)); return function _u(e, t, n, r) { let i = !1; if (Cd()) { const o = function kw(e, t, n) { const r = e.directiveRegistry; let i = null; if (r) for (let o = 0; o < r.length; o++) { const s = r[o]; $f(n, s.selectors, !1) && (i || (i = []), To(ai(n, t), e, s.type), At(s) ? (hh(e, n), i.unshift(s)) : i.push(s)) } return i }(e, t, n), s = null === r ? null : { "": -1 }; if (null !== o) { i = !0, ph(n, e.data.length, o.length); for (let c = 0; c < o.length; c++) { const d = o[c]; d.providersResolver && d.providersResolver(d) } let a = !1, u = !1, l = _r(e, t, o.length, null); for (let c = 0; c < o.length; c++) { const d = o[c]; n.mergedAttrs = bo(n.mergedAttrs, d.hostAttrs), gh(e, n, t, l, d), jw(l, d, s), null !== d.contentQueries && (n.flags |= 8), (null !== d.hostBindings || null !== d.hostAttrs || 0 !== d.hostVars) && (n.flags |= 128); const f = d.type.prototype; !a && (f.ngOnChanges || f.ngOnInit || f.ngDoCheck) && ((e.preOrderHooks || (e.preOrderHooks = [])).push(n.index), a = !0), !u && (f.ngOnChanges || f.ngDoCheck) && ((e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n.index), u = !0), l++ } !function Sw(e, t) { const r = t.directiveEnd, i = e.data, o = t.attrs, s = []; let a = null, u = null; for (let l = t.directiveStart; l < r; l++) { const c = i[l], d = c.inputs, f = null === o || Uf(t) ? null : Hw(d, o); s.push(f), a = lh(d, l, a), u = lh(c.outputs, l, u) } null !== a && (a.hasOwnProperty("class") && (t.flags |= 16), a.hasOwnProperty("style") && (t.flags |= 32)), t.initialInputs = s, t.inputs = a, t.outputs = u }(e, n) } s && function Lw(e, t, n) { if (t) { const r = e.localNames = []; for (let i = 0; i < t.length; i += 2) { const o = n[t[i + 1]]; if (null == o) throw new K(-301, !1); r.push(t[i], o) } } }(n, r, s) } return n.mergedAttrs = bo(n.mergedAttrs, n.attrs), i }(t, n, l, wn(a, s)), null !== l.attrs && Go(l, l.attrs, !1), null !== l.mergedAttrs && Go(l, l.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, l), l }(s, o, i, 0, t, n, r) : o.data[s]; Ut(l, !0); const c = l.mergedAttrs; null !== c && Eo(a, u, c); const d = l.classes; null !== d && su(a, u, d); const f = l.styles; return null !== f && Bf(a, u, f), 64 != (64 & l.flags) && Bo(o, i, u, l), 0 === function BD() { return N.lFrame.elementDepthCount }() && ze(u, i), function VD() { N.lFrame.elementDepthCount++ }(), go(l) && (function Du(e, t, n) { !Cd() || (function Nw(e, t, n, r) { const i = n.directiveStart, o = n.directiveEnd; e.firstCreatePass || ai(n, t), ze(r, t); const s = n.initialInputs; for (let a = i; a < o; a++) { const u = e.data[a], l = At(u); l && Bw(t, n, u); const c = ui(t, e, a, n); ze(c, t), null !== s && Vw(0, a - i, c, u, 0, s), l && (at(n.index, t)[8] = c) } }(e, t, n, Dt(n, t)), 128 == (128 & n.flags) && function Fw(e, t, n) { const r = n.directiveStart, i = n.directiveEnd, s = n.index, a = function QD() { return N.lFrame.currentDirectiveIndex }(); try { En(s); for (let u = r; u < i; u++) { const l = e.data[u], c = t[u]; _a(u), (null !== l.hostBindings || 0 !== l.hostVars || null !== l.hostAttrs) && fh(l, c) } } finally { En(-1), _a(a) } }(e, t, n)) }(o, i, l), function ih(e, t, n) { if (la(t)) { const i = t.directiveEnd; for (let o = t.directiveStart; o < i; o++) { const s = e.data[o]; s.contentQueries && s.contentQueries(1, n[o], o) } } }(o, l, i)), null !== r && function Cu(e, t, n = Dt) { const r = t.localNames; if (null !== r) { let i = t.index + 1; for (let o = 0; o < r.length; o += 2) { const s = r[o + 1], a = -1 === s ? n(t, e) : e[s]; e[i++] = a } } }(i, l), he } function we() { let e = Ie(); Da() ? function Ca() { N.lFrame.isParent = !1 }() : (e = e.parent, Ut(e, !1)); const t = e; !function HD() { N.lFrame.elementDepthCount-- }(); const n = Q(); return n.firstCreatePass && (Co(n, e), la(e) && n.queries.elementEnd(e)), null != t.classesWithoutHost && function aC(e) { return 0 != (16 & e.flags) }(t) && Uu(n, t, v(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function uC(e) { return 0 != (32 & e.flags) }(t) && Uu(n, t, v(), t.stylesWithoutHost, !1), we } function Ye(e, t, n, r) { return he(e, t, n, r), we(), Ye } function Yo(e) { return !!e && "function" == typeof e.then } const cp = function lp(e) { return !!e && "function" == typeof e.subscribe }; function kr(e, t, n, r) { const i = v(), o = Q(), s = Ie(); return function fp(e, t, n, r, i, o, s, a) { const u = go(r), c = e.firstCreatePass && Dh(e), d = t[8], f = vh(t); let h = !0; if (3 & r.type || a) { const C = Dt(r, t), _ = a ? a(C) : C, g = f.length, I = a ? H => a(Ce(H[r.index])) : r.index; if (ge(n)) { let H = null; if (!a && u && (H = function KE(e, t, n, r) { const i = e.cleanup; if (null != i) for (let o = 0; o < i.length - 1; o += 2) { const s = i[o]; if (s === n && i[o + 1] === r) { const a = t[7], u = i[o + 2]; return a.length > u ? a[u] : null } "string" == typeof s && (o += 2) } return null }(e, t, i, r.index)), null !== H) (H.__ngLastListenerFn__ || H).__ngNextListenerFn__ = o, H.__ngLastListenerFn__ = o, h = !1; else { o = qu(r, t, d, o, !1); const Y = n.listen(_, i, o); f.push(o, Y), c && c.push(i, I, g, g + 1) } } else o = qu(r, t, d, o, !0), _.addEventListener(i, o, s), f.push(o), c && c.push(i, I, g, s) } else o = qu(r, t, d, o, !1); const p = r.outputs; let m; if (h && null !== p && (m = p[i])) { const C = m.length; if (C) for (let _ = 0; _ < C; _ += 2) { const pt = t[m[_]][m[_ + 1]].subscribe(o), er = f.length; f.push(o, pt), c && c.push(i, r.index, er, -(er + 1)) } } }(o, i, i[j], s, e, t, !!n, r), kr } function hp(e, t, n, r) { try { return !1 !== n(r) } catch (i) { return _h(e, i), !1 } } function qu(e, t, n, r, i) { return function o(s) { if (s === Function) return r; const a = 2 & e.flags ? at(e.index, t) : t; 0 == (32 & t[2]) && bu(a); let u = hp(t, 0, r, s), l = o.__ngNextListenerFn__; for (; l;)u = hp(t, 0, l, s) && u, l = l.__ngNextListenerFn__; return i && !1 === u && (s.preventDefault(), s.returnValue = !1), u } } function nt(e, t = "") { const n = v(), r = Q(), i = e + 20, o = r.firstCreatePass ? Cr(r, i, 1, t, null) : r.data[i], s = n[i] = function Xa(e, t) { return ge(e) ? e.createText(t) : e.createTextNode(t) }(n[j], t); Bo(r, n, s, o), Ut(o, !1) } const Jo = "en-US"; let sg = Jo; class Rg { } class $b { resolveComponentFactory(t) { throw function Ub(e) { const t = Error(`No component factory found for ${J(e)}. Did you add it to @NgModule.entryComponents?`); return t.ngComponent = e, t }(t) } } let Fi = (() => { class e { } return e.NULL = new $b, e })(); function zb() { return Vr(Ie(), v()) } function Vr(e, t) { return new An(Dt(e, t)) } let An = (() => { class e { constructor(n) { this.nativeElement = n } } return e.__NG_ELEMENT_ID__ = zb, e })(); function qb(e) { return e instanceof An ? e.nativeElement : e } class Og { } let Qb = (() => { class e { } return e.\u0275prov = W({ token: e, providedIn: "root", factory: () => null }), e })(); class is { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const Zb = new is("13.3.10"), tl = {}; function os(e, t, n, r, i = !1) { for (; null !== n;) { const o = t[n.index]; if (null !== o && r.push(Ce(o)), St(o)) for (let a = 10; a < o.length; a++) { const u = o[a], l = u[1].firstChild; null !== l && os(u[1], u, l, r) } const s = n.type; if (8 & s) os(e, t, n.child, r); else if (32 & s) { const a = Ya(n, t); let u; for (; u = a();)r.push(u) } else if (16 & s) { const a = kf(t, n); if (Array.isArray(a)) r.push(...a); else { const u = Ei(t[16]); os(u[1], u, a, r, !0) } } n = i ? n.projectionNext : n.next } return r } class ki { constructor(t, n) { this._lView = t, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const t = this._lView, n = t[1]; return os(n, t, n.firstChild, []) } get context() { return this._lView[8] } set context(t) { this._lView[8] = t } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[3]; if (St(t)) { const n = t[8], r = n ? n.indexOf(this) : -1; r > -1 && (tu(t, r), Ao(n, r)) } this._attachedToViewContainer = !1 } Tf(this._lView[1], this._lView) } onDestroy(t) { uh(this._lView[1], this._lView, null, t) } markForCheck() { bu(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { !function Iu(e, t, n) { const r = t[10]; r.begin && r.begin(); try { wr(e, t, e.template, n) } catch (i) { throw _h(t, i), i } finally { r.end && r.end() } }(this._lView[1], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new K(902, ""); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function $_(e, t) { bi(e, t, t[j], 2, null, null) }(this._lView[1], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new K(902, ""); this._appRef = t } } class Yb extends ki { constructor(t) { super(t), this._view = t } detectChanges() { yh(this._view) } checkNoChanges() { } get context() { return null } } class Ng extends Fi { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const n = Ue(t); return new nl(n, this.ngModule) } } function Fg(e) { const t = []; for (let n in e) e.hasOwnProperty(n) && t.push({ propName: e[n], templateName: n }); return t } class nl extends Rg { constructor(t, n) { super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = function lw(e) { return e.map(uw).join(",") }(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!n } get inputs() { return Fg(this.componentDef.inputs) } get outputs() { return Fg(this.componentDef.outputs) } create(t, n, r, i) { const o = (i = i || this.ngModule) ? function Jb(e, t) { return { get: (n, r, i) => { const o = e.get(n, tl, i); return o !== tl || r === tl ? o : t.get(n, r, i) } } }(t, i.injector) : t, s = o.get(Og, md), a = o.get(Qb, null), u = s.createRenderer(null, this.componentDef), l = this.componentDef.selectors[0][0] || "div", c = r ? function ah(e, t, n) { if (ge(e)) return e.selectRootElement(t, n === Bt.ShadowDom); let r = "string" == typeof t ? e.querySelector(t) : t; return r.textContent = "", r }(u, r, this.componentDef.encapsulation) : eu(s.createRenderer(null, this.componentDef), l, function Kb(e) { const t = e.toLowerCase(); return "svg" === t ? "svg" : "math" === t ? "math" : null }(l)), d = this.componentDef.onPush ? 576 : 528, f = function Bh(e, t) { return { components: [], scheduler: e || F_, clean: Qw, playerHandler: t || null, flags: 0 } }(), h = zo(0, null, null, 1, 0, null, null, null, null, null), p = Mi(null, h, f, d, null, null, s, u, a, o); let m, C; vo(p); try { const _ = function Lh(e, t, n, r, i, o) { const s = n[1]; n[20] = e; const u = Cr(s, 20, 2, "#host", null), l = u.mergedAttrs = t.hostAttrs; null !== l && (Go(u, l, !0), null !== e && (Eo(i, e, l), null !== u.classes && su(i, e, u.classes), null !== u.styles && Bf(i, e, u.styles))); const c = r.createRenderer(e, t), d = Mi(n, oh(t), null, t.onPush ? 64 : 16, n[20], u, r, c, o || null, null); return s.firstCreatePass && (To(ai(u, n), s, t.type), hh(s, u), ph(u, n.length, 1)), qo(n, d), n[20] = d }(c, this.componentDef, p, s, u); if (c) if (r) Eo(u, c, ["ng-version", Zb.full]); else { const { attrs: g, classes: I } = function cw(e) { const t = [], n = []; let r = 1, i = 2; for (; r < e.length;) { let o = e[r]; if ("string" == typeof o) 2 === i ? "" !== o && t.push(o, e[++r]) : 8 === i && n.push(o); else { if (!xt(i)) break; i = o } r++ } return { attrs: t, classes: n } }(this.componentDef.selectors[0]); g && Eo(u, c, g), I && I.length > 0 && su(u, c, I.join(" ")) } if (C = function ma(e, t) { return e.data[t] }(h, 20), void 0 !== n) { const g = C.projection = []; for (let I = 0; I < this.ngContentSelectors.length; I++) { const H = n[I]; g.push(null != H ? Array.from(H) : null) } } m = function jh(e, t, n, r, i) { const o = n[1], s = function Pw(e, t, n) { const r = Ie(); e.firstCreatePass && (n.providersResolver && n.providersResolver(n), gh(e, r, t, _r(e, t, 1, null), n)); const i = ui(t, e, r.directiveStart, r); ze(i, t); const o = Dt(r, t); return o && ze(o, t), i }(o, n, t); if (r.components.push(s), e[8] = s, i && i.forEach(u => u(s, t)), t.contentQueries) { const u = Ie(); t.contentQueries(1, s, u.directiveStart) } const a = Ie(); return !o.firstCreatePass || null === t.hostBindings && null === t.hostAttrs || (En(a.index), dh(n[1], a, 0, a.directiveStart, a.directiveEnd, t), fh(t, s)), s }(_, this.componentDef, p, f, [pE]), Ii(h, p, null) } finally { Do() } return new eM(this.componentType, m, Vr(C, p), p, C) } } class eM extends class Hb { }{ constructor(t, n, r, i, o) { super(), this.location = r, this._rootLView = i, this._tNode = o, this.instance = n, this.hostView = this.changeDetectorRef = new Yb(i), this.componentType = t } get injector() { return new cr(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } class dn { } class kg { } const Hr = new Map; class Bg extends dn { constructor(t, n) { super(), this._parent = n, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new Ng(this); const r = mt(t); this._bootstrapComponents = qt(r.bootstrap), this._r3Injector = Ih(t, n, [{ provide: dn, useValue: this }, { provide: Fi, useValue: this.componentFactoryResolver }], J(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t) } get(t, n = dt.THROW_IF_NOT_FOUND, r = P.Default) { return t === dt || t === dn || t === Su ? this : this._r3Injector.get(t, n, r) } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class rl extends kg { constructor(t) { super(), this.moduleType = t, null !== mt(t) && function nM(e) { const t = new Set; !function n(r) { const i = mt(r, !0), o = i.id; null !== o && (function Lg(e, t, n) { if (t && t !== n) throw new Error(`Duplicate module registered for ${e} - ${J(t)} vs ${J(t.name)}`) }(o, Hr.get(o), r), Hr.set(o, r)); const s = qt(i.imports); for (const a of s) t.has(a) || (t.add(a), n(a)) }(e) }(t) } create(t) { return new Bg(this.moduleType, t) } } function il(e) { return t => { setTimeout(e, void 0, t) } } const Je = class CM extends Xt { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, n, r) { var i, o, s; let a = t, u = n || (() => null), l = r; if (t && "object" == typeof t) { const d = t; a = null === (i = d.next) || void 0 === i ? void 0 : i.bind(d), u = null === (o = d.error) || void 0 === o ? void 0 : o.bind(d), l = null === (s = d.complete) || void 0 === s ? void 0 : s.bind(d) } this.__isAsync && (u = il(u), a && (a = il(a)), l && (l = il(l))); const c = super.subscribe({ next: a, error: u, complete: l }); return t instanceof oe && t.add(c), c } }; function _M() { return this._results[Mr()]() } class ol { constructor(t = !1) { this._emitDistinctChangesOnly = t, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const n = Mr(), r = ol.prototype; r[n] || (r[n] = _M) } get changes() { return this._changes || (this._changes = new Je) } get(t) { return this._results[t] } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, n) { return this._results.reduce(t, n) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t, n) { const r = this; r.dirty = !1; const i = Ct(t); (this._changesDetected = !function DC(e, t, n) { if (e.length !== t.length) return !1; for (let r = 0; r < e.length; r++) { let i = e[r], o = t[r]; if (n && (i = n(i), o = n(o)), o !== i) return !1 } return !0 }(r._results, i, n)) && (r._results = i, r.length = i.length, r.last = i[this.length - 1], r.first = i[0]) } notifyOnChanges() { this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } Symbol; let fn = (() => { class e { } return e.__NG_ELEMENT_ID__ = bM, e })(); const wM = fn, EM = class extends wM { constructor(t, n, r) { super(), this._declarationLView = t, this._declarationTContainer = n, this.elementRef = r } createEmbeddedView(t) { const n = this._declarationTContainer.tViews, r = Mi(this._declarationLView, n, t, 16, null, n.declTNode, null, null, null, null); r[17] = this._declarationLView[this._declarationTContainer.index]; const o = this._declarationLView[19]; return null !== o && (r[19] = o.createEmbeddedView(n)), Ii(n, r, t), new ki(r) } }; function bM() { return ss(Ie(), v()) } function ss(e, t) { return 4 & e.type ? new EM(t, e, Vr(e, t)) : null } let Ft = (() => { class e { } return e.__NG_ELEMENT_ID__ = MM, e })(); function MM() { return Wg(Ie(), v()) } const IM = Ft, qg = class extends IM { constructor(t, n, r) { super(), this._lContainer = t, this._hostTNode = n, this._hostLView = r } get element() { return Vr(this._hostTNode, this._hostLView) } get injector() { return new cr(this._hostTNode, this._hostLView) } get parentInjector() { const t = Io(this._hostTNode, this._hostLView); if (Od(t)) { const n = lr(t, this._hostLView), r = ur(t); return new cr(n[1].data[r + 8], n) } return new cr(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const n = Gg(this._lContainer); return null !== n && n[t] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(t, n, r) { const i = t.createEmbeddedView(n || {}); return this.insert(i, r), i } createComponent(t, n, r, i, o) { const s = t && !function di(e) { return "function" == typeof e }(t); let a; if (s) a = n; else { const d = n || {}; a = d.index, r = d.injector, i = d.projectableNodes, o = d.ngModuleRef } const u = s ? t : new nl(Ue(t)), l = r || this.parentInjector; if (!o && null == u.ngModule) { const f = (s ? l : this.parentInjector).get(dn, null); f && (o = f) } const c = u.create(l, i, void 0, o); return this.insert(c.hostView, a), c } insert(t, n) { const r = t._lView, i = r[1]; if (function jD(e) { return St(e[3]) }(r)) { const c = this.indexOf(t); if (-1 !== c) this.detach(c); else { const d = r[3], f = new qg(d, d[6], d[3]); f.detach(f.indexOf(t)) } } const o = this._adjustIndex(n), s = this._lContainer; !function q_(e, t, n, r) { const i = 10 + r, o = n.length; r > 0 && (n[i - 1][4] = t), r < o - 10 ? (t[4] = n[i], $d(n, 10 + r, t)) : (n.push(t), t[4] = null), t[3] = n; const s = t[17]; null !== s && n !== s && function G_(e, t) { const n = e[9]; t[16] !== t[3][3][16] && (e[2] = !0), null === n ? e[9] = [t] : n.push(t) }(s, t); const a = t[19]; null !== a && a.insertView(e), t[2] |= 128 }(i, r, s, o); const a = iu(o, s), u = r[j], l = jo(u, s[7]); return null !== l && function U_(e, t, n, r, i, o) { r[0] = i, r[6] = t, bi(e, r, n, 1, i, o) }(i, s[6], u, r, l, a), t.attachToViewContainerRef(), $d(sl(s), o, t), t } move(t, n) { return this.insert(t, n) } indexOf(t) { const n = Gg(this._lContainer); return null !== n ? n.indexOf(t) : -1 } remove(t) { const n = this._adjustIndex(t, -1), r = tu(this._lContainer, n); r && (Ao(sl(this._lContainer), n), Tf(r[1], r)) } detach(t) { const n = this._adjustIndex(t, -1), r = tu(this._lContainer, n); return r && null != Ao(sl(this._lContainer), n) ? new ki(r) : null } _adjustIndex(t, n = 0) { return null == t ? this.length + n : t } }; function Gg(e) { return e[8] } function sl(e) { return e[8] || (e[8] = []) } function Wg(e, t) { let n; const r = t[e.index]; if (St(r)) n = r; else { let i; if (8 & e.type) i = Ce(r); else { const o = t[j]; i = o.createComment(""); const s = Dt(e, t); $n(o, jo(o, s), i, function Y_(e, t) { return ge(e) ? e.nextSibling(t) : t.nextSibling }(o, s), !1) } t[e.index] = n = function mh(e, t, n, r) { return new Array(e, !0, !1, t, null, 0, r, n, null, null) }(r, t, i, e), qo(t, n) } return new qg(n, e, t) } class al { constructor(t) { this.queryList = t, this.matches = null } clone() { return new al(this.queryList) } setDirty() { this.queryList.setDirty() } } class ul { constructor(t = []) { this.queries = t } createEmbeddedView(t) { const n = t.queries; if (null !== n) { const r = null !== t.contentQueries ? t.contentQueries[0] : n.length, i = []; for (let o = 0; o < r; o++) { const s = n.getByIndex(o); i.push(this.queries[s.indexInDeclarationView].clone()) } return new ul(i) } return null } insertView(t) { this.dirtyQueriesWithMatches(t) } detachView(t) { this.dirtyQueriesWithMatches(t) } dirtyQueriesWithMatches(t) { for (let n = 0; n < this.queries.length; n++)null !== Xg(t, n).matches && this.queries[n].setDirty() } } class Qg { constructor(t, n, r = null) { this.predicate = t, this.flags = n, this.read = r } } class ll { constructor(t = []) { this.queries = t } elementStart(t, n) { for (let r = 0; r < this.queries.length; r++)this.queries[r].elementStart(t, n) } elementEnd(t) { for (let n = 0; n < this.queries.length; n++)this.queries[n].elementEnd(t) } embeddedTView(t) { let n = null; for (let r = 0; r < this.length; r++) { const i = null !== n ? n.length : 0, o = this.getByIndex(r).embeddedTView(t, i); o && (o.indexInDeclarationView = r, null !== n ? n.push(o) : n = [o]) } return null !== n ? new ll(n) : null } template(t, n) { for (let r = 0; r < this.queries.length; r++)this.queries[r].template(t, n) } getByIndex(t) { return this.queries[t] } get length() { return this.queries.length } track(t) { this.queries.push(t) } } class cl { constructor(t, n = -1) { this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = n } elementStart(t, n) { this.isApplyingToNode(n) && this.matchTNode(t, n) } elementEnd(t) { this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1) } template(t, n) { this.elementStart(t, n) } embeddedTView(t, n) { return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, n), new cl(this.metadata)) : null } isApplyingToNode(t) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const n = this._declarationNodeIndex; let r = t.parent; for (; null !== r && 8 & r.type && r.index !== n;)r = r.parent; return n === (null !== r ? r.index : -1) } return this._appliesToNextNode } matchTNode(t, n) { const r = this.metadata.predicate; if (Array.isArray(r)) for (let i = 0; i < r.length; i++) { const o = r[i]; this.matchTNodeWithReadOption(t, n, AM(n, o)), this.matchTNodeWithReadOption(t, n, So(n, t, o, !1, !1)) } else r === fn ? 4 & n.type && this.matchTNodeWithReadOption(t, n, -1) : this.matchTNodeWithReadOption(t, n, So(n, t, r, !1, !1)) } matchTNodeWithReadOption(t, n, r) { if (null !== r) { const i = this.metadata.read; if (null !== i) if (i === An || i === Ft || i === fn && 4 & n.type) this.addMatch(n.index, -2); else { const o = So(n, t, i, !1, !1); null !== o && this.addMatch(n.index, o) } else this.addMatch(n.index, r) } } addMatch(t, n) { null === this.matches ? this.matches = [t, n] : this.matches.push(t, n) } } function AM(e, t) { const n = e.localNames; if (null !== n) for (let r = 0; r < n.length; r += 2)if (n[r] === t) return n[r + 1]; return null } function RM(e, t, n, r) { return -1 === n ? function xM(e, t) { return 11 & e.type ? Vr(e, t) : 4 & e.type ? ss(e, t) : null }(t, e) : -2 === n ? function PM(e, t, n) { return n === An ? Vr(t, e) : n === fn ? ss(t, e) : n === Ft ? Wg(t, e) : void 0 }(e, t, r) : ui(e, e[1], n, t) } function Zg(e, t, n, r) { const i = t[19].queries[r]; if (null === i.matches) { const o = e.data, s = n.matches, a = []; for (let u = 0; u < s.length; u += 2) { const l = s[u]; a.push(l < 0 ? null : RM(t, o[l], s[u + 1], n.metadata.read)) } i.matches = a } return i.matches } function dl(e, t, n, r) { const i = e.queries.getByIndex(n), o = i.matches; if (null !== o) { const s = Zg(e, t, i, n); for (let a = 0; a < o.length; a += 2) { const u = o[a]; if (u > 0) r.push(s[a / 2]); else { const l = o[a + 1], c = t[-u]; for (let d = 10; d < c.length; d++) { const f = c[d]; f[17] === f[3] && dl(f[1], f, l, r) } if (null !== c[9]) { const d = c[9]; for (let f = 0; f < d.length; f++) { const h = d[f]; dl(h[1], h, l, r) } } } } } return r } function as(e) { const t = v(), n = Q(), r = bd(); Ea(r + 1); const i = Xg(n, r); if (e.dirty && yd(t) === (2 == (2 & i.metadata.flags))) { if (null === i.matches) e.reset([]); else { const o = i.crossesNgTemplate ? dl(n, t, r, []) : Zg(n, t, i, r); e.reset(o, qb), e.notifyOnChanges() } return !0 } return !1 } function Yg(e, t, n) { const r = Q(); r.firstCreatePass && (function Jg(e, t, n) { null === e.queries && (e.queries = new ll), e.queries.track(new cl(t, n)) }(r, new Qg(e, t, n), -1), 2 == (2 & t) && (r.staticViewQueries = !0)), function Kg(e, t, n) { const r = new ol(4 == (4 & n)); uh(e, t, r, r.destroy), null === t[19] && (t[19] = new ul), t[19].queries.push(new al(r)) }(r, v(), t) } function Xg(e, t) { return e.queries.getByIndex(t) } function ds(...e) { } const vl = new Z("Application Initializer"); let Dl = (() => { class e { constructor(n) { this.appInits = n, this.resolve = ds, this.reject = ds, this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, i) => { this.resolve = r, this.reject = i }) } runInitializers() { if (this.initialized) return; const n = [], r = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let i = 0; i < this.appInits.length; i++) { const o = this.appInits[i](); if (Yo(o)) n.push(o); else if (cp(o)) { const s = new Promise((a, u) => { o.subscribe({ complete: a, error: u }) }); n.push(s) } } Promise.all(n).then(() => { r() }).catch(i => { this.reject(i) }), 0 === n.length && r(), this.initialized = !0 } } return e.\u0275fac = function (n) { return new (n || e)(R(vl, 8)) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const Vi = new Z("AppId", { providedIn: "root", factory: function mm() { return `${Cl()}${Cl()}${Cl()}` } }); function Cl() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const ym = new Z("Platform Initializer"), vm = new Z("Platform ID", { providedIn: "platform", factory: () => "unknown" }), Dm = new Z("appBootstrapListener"); let JM = (() => { class e { log(n) { console.log(n) } warn(n) { console.warn(n) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); const xn = new Z("LocaleId", { providedIn: "root", factory: () => PC(xn, P.Optional | P.SkipSelf) || function XM() { return "undefined" != typeof $localize && $localize.locale || Jo }() }); class tI { constructor(t, n) { this.ngModuleFactory = t, this.componentFactories = n } } let Cm = (() => { class e { compileModuleSync(n) { return new rl(n) } compileModuleAsync(n) { return Promise.resolve(this.compileModuleSync(n)) } compileModuleAndAllComponentsSync(n) { const r = this.compileModuleSync(n), o = qt(mt(n).declarations).reduce((s, a) => { const u = Ue(a); return u && s.push(new nl(u)), s }, []); return new tI(r, o) } compileModuleAndAllComponentsAsync(n) { return Promise.resolve(this.compileModuleAndAllComponentsSync(n)) } clearCache() { } clearCacheFor(n) { } getModuleId(n) { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const rI = (() => Promise.resolve(0))(); function _l(e) { "undefined" == typeof Zone ? rI.then(() => { e && e.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", e) } class Le { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Je(!1), this.onMicrotaskEmpty = new Je(!1), this.onStable = new Je(!1), this.onError = new Je(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const i = this; i._nesting = 0, i._outer = i._inner = Zone.current, Zone.TaskTrackingZoneSpec && (i._inner = i._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (i._inner = i._inner.fork(Zone.longStackTraceZoneSpec)), i.shouldCoalesceEventChangeDetection = !r && n, i.shouldCoalesceRunChangeDetection = r, i.lastRequestAnimationFrameId = -1, i.nativeRequestAnimationFrame = function iI() { let e = X.requestAnimationFrame, t = X.cancelAnimationFrame; if ("undefined" != typeof Zone && e && t) { const n = e[Zone.__symbol__("OriginalDelegate")]; n && (e = n); const r = t[Zone.__symbol__("OriginalDelegate")]; r && (t = r) } return { nativeRequestAnimationFrame: e, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function aI(e) { const t = () => { !function sI(e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(X, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, El(e), e.isCheckStableRunning = !0, wl(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), El(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, i, o, s, a) => { try { return _m(e), n.invokeTask(i, o, s, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === o.type || e.shouldCoalesceRunChangeDetection) && t(), wm(e) } }, onInvoke: (n, r, i, o, s, a, u) => { try { return _m(e), n.invoke(i, o, s, a, u) } finally { e.shouldCoalesceRunChangeDetection && t(), wm(e) } }, onHasTask: (n, r, i, o) => { n.hasTask(i, o), r === i && ("microTask" == o.change ? (e._hasPendingMicrotasks = o.microTask, El(e), wl(e)) : "macroTask" == o.change && (e.hasPendingMacrotasks = o.macroTask)) }, onHandleError: (n, r, i, o) => (n.handleError(i, o), e.runOutsideAngular(() => e.onError.emit(o)), !1) }) }(i) } static isInAngularZone() { return "undefined" != typeof Zone && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Le.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Le.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, n, r) { return this._inner.run(t, n, r) } runTask(t, n, r, i) { const o = this._inner, s = o.scheduleEventTask("NgZoneEvent: " + i, t, oI, ds, ds); try { return o.runTask(s, n, r) } finally { o.cancelTask(s) } } runGuarded(t, n, r) { return this._inner.runGuarded(t, n, r) } runOutsideAngular(t) { return this._outer.run(t) } } const oI = {}; function wl(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function El(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function _m(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function wm(e) { e._nesting--, wl(e) } class uI { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Je, this.onMicrotaskEmpty = new Je, this.onStable = new Je, this.onError = new Je } run(t, n, r) { return t.apply(n, r) } runGuarded(t, n, r) { return t.apply(n, r) } runOutsideAngular(t) { return t() } runTask(t, n, r, i) { return t.apply(n, r) } } let bl = (() => { class e { constructor(n) { this._ngZone = n, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), n.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Le.assertNotInAngularZone(), _l(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) _l(() => { for (; 0 !== this._callbacks.length;) { let n = this._callbacks.pop(); clearTimeout(n.timeoutId), n.doneCb(this._didWork) } this._didWork = !1 }); else { let n = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(n) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({ source: n.source, creationLocation: n.creationLocation, data: n.data })) : [] } addCallback(n, r, i) { let o = -1; r && r > 0 && (o = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== o), n(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: n, timeoutId: o, updateCb: i }) } whenStable(n, r, i) { if (i && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(n, r, i), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(n, r, i) { return [] } } return e.\u0275fac = function (n) { return new (n || e)(R(Le)) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac }), e })(), lI = (() => { class e { constructor() { this._applications = new Map, Ml.addToWindow(this) } registerApplication(n, r) { this._applications.set(n, r) } unregisterApplication(n) { this._applications.delete(n) } unregisterAllApplications() { this._applications.clear() } getTestability(n) { return this._applications.get(n) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(n, r = !0) { return Ml.findTestabilityInTree(this, n, r) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); class cI { addToWindow(t) { } findTestabilityInTree(t, n, r) { return null } } let Ml = new cI, Gn = null; const Em = new Z("AllowMultipleToken"), bm = new Z("PlatformOnDestroy"); class Mm { constructor(t, n) { this.name = t, this.token = n } } function Im(e, t, n = []) { const r = `Platform: ${t}`, i = new Z(r); return (o = []) => { let s = Il(); if (!s || s.injector.get(Em, !1)) { const a = [...n, ...o, { provide: i, useValue: !0 }]; e ? e(a) : function pI(e) { if (Gn && !Gn.get(Em, !1)) throw new K(400, ""); Gn = e; const t = e.get(Tm), n = e.get(ym, null); n && n.forEach(r => r()) }(function mI(e = [], t) { return dt.create({ name: t, providers: [{ provide: Au, useValue: "platform" }, { provide: bm, useValue: () => Gn = null }, ...e] }) }(a, r)) } return function gI(e) { const t = Il(); if (!t) throw new K(401, ""); return t }() } } function Il() { var e; return null !== (e = null == Gn ? void 0 : Gn.get(Tm)) && void 0 !== e ? e : null } let Tm = (() => { class e { constructor(n) { this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(n, r) { const a = function yI(e, t) { let n; return n = "noop" === e ? new uI : ("zone.js" === e ? void 0 : e) || new Le({ enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !!(null == t ? void 0 : t.ngZoneEventCoalescing), shouldCoalesceRunChangeDetection: !!(null == t ? void 0 : t.ngZoneRunCoalescing) }), n }(r ? r.ngZone : void 0, { ngZoneEventCoalescing: r && r.ngZoneEventCoalescing || !1, ngZoneRunCoalescing: r && r.ngZoneRunCoalescing || !1 }), u = [{ provide: Le, useValue: a }]; return a.run(() => { const l = dt.create({ providers: u, parent: this.injector, name: n.moduleType.name }), c = n.create(l), d = c.injector.get(wi, null); if (!d) throw new K(402, ""); return a.runOutsideAngular(() => { const f = a.onError.subscribe({ next: h => { d.handleError(h) } }); c.onDestroy(() => { Sl(this._modules, c), f.unsubscribe() }) }), function vI(e, t, n) { try { const r = n(); return Yo(r) ? r.catch(i => { throw t.runOutsideAngular(() => e.handleError(i)), i }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } }(d, a, () => { const f = c.injector.get(Dl); return f.runInitializers(), f.donePromise.then(() => (function q0(e) { ot(e, "Expected localeId to be defined"), "string" == typeof e && (sg = e.toLowerCase().replace(/_/g, "-")) }(c.injector.get(xn, Jo) || Jo), this._moduleDoBootstrap(c), c)) }) }) } bootstrapModule(n, r = []) { const i = Sm({}, r); return function fI(e, t, n) { const r = new rl(n); return Promise.resolve(r) }(0, 0, n).then(o => this.bootstrapModuleFactory(o, i)) } _moduleDoBootstrap(n) { const r = n.injector.get(Tl); if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(i => r.bootstrap(i)); else { if (!n.instance.ngDoBootstrap) throw new K(403, ""); n.instance.ngDoBootstrap(r) } this._modules.push(n) } onDestroy(n) { this._destroyListeners.push(n) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new K(404, ""); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()); const n = this._injector.get(bm, null); null == n || n(), this._destroyed = !0 } get destroyed() { return this._destroyed } } return e.\u0275fac = function (n) { return new (n || e)(R(dt)) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); function Sm(e, t) { return Array.isArray(t) ? t.reduce(Sm, e) : Object.assign(Object.assign({}, e), t) } let Tl = (() => { class e { constructor(n, r, i, o) { this._zone = n, this._injector = r, this._exceptionHandler = i, this._initStatus = o, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const s = new Me(u => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { u.next(this._stable), u.complete() }) }), a = new Me(u => { let l; this._zone.runOutsideAngular(() => { l = this._zone.onStable.subscribe(() => { Le.assertNotInAngularZone(), _l(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, u.next(!0)) }) }) }); const c = this._zone.onUnstable.subscribe(() => { Le.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { u.next(!1) })) }); return () => { l.unsubscribe(), c.unsubscribe() } }); this.isStable = function rD(...e) { const t = Xr(e), n = function Yv(e, t) { return "number" == typeof Ys(e) ? e.pop() : t }(e, 1 / 0), r = e; return r.length ? 1 === r.length ? en(r[0]) : Jr(n)(Fe(r, t)) : nn }(s, a.pipe(function iD(e = {}) { const { connector: t = (() => new Xt), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: i = !0 } = e; return o => { let s = null, a = null, u = null, l = 0, c = !1, d = !1; const f = () => { null == a || a.unsubscribe(), a = null }, h = () => { f(), s = u = null, c = d = !1 }, p = () => { const m = s; h(), null == m || m.unsubscribe() }; return Oe((m, C) => { l++, !d && !c && f(); const _ = u = null != u ? u : t(); C.add(() => { l--, 0 === l && !d && !c && (a = Ks(p, i)) }), _.subscribe(C), s || (s = new io({ next: g => _.next(g), error: g => { d = !0, f(), a = Ks(h, n, g), _.error(g) }, complete: () => { c = !0, f(), a = Ks(h, r), _.complete() } }), Fe(m).subscribe(s)) })(o) } }())) } bootstrap(n, r) { if (!this._initStatus.done) throw new K(405, ""); let i; i = n instanceof Rg ? n : this._injector.get(Fi).resolveComponentFactory(n), this.componentTypes.push(i.componentType); const o = function hI(e) { return e.isBoundToModule }(i) ? void 0 : this._injector.get(dn), a = i.create(dt.NULL, [], r || i.selector, o), u = a.location.nativeElement, l = a.injector.get(bl, null), c = l && a.injector.get(lI); return l && c && c.registerApplication(u, l), a.onDestroy(() => { this.detachView(a.hostView), Sl(this.components, a), c && c.unregisterApplication(u) }), this._loadComponent(a), a } tick() { if (this._runningTick) throw new K(101, ""); try { this._runningTick = !0; for (let n of this._views) n.detectChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1 } } attachView(n) { const r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { const r = n; Sl(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n), this._injector.get(Dm, []).concat(this._bootstrapListeners).forEach(i => i(n)) } ngOnDestroy() { this._views.slice().forEach(n => n.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } get viewCount() { return this._views.length } } return e.\u0275fac = function (n) { return new (n || e)(R(Le), R(dt), R(wi), R(Dl)) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function Sl(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } let xm = !0, Al = (() => { class e { } return e.__NG_ELEMENT_ID__ = _I, e })(); function _I(e) { return function wI(e, t, n) { if (po(e) && !n) { const r = at(e.index, t); return new ki(r, r) } return 47 & e.type ? new ki(t[16], t) : null }(Ie(), v(), 16 == (16 & e)) } const FI = Im(null, "core", []); let kI = (() => { class e { constructor(n) { } } return e.\u0275fac = function (n) { return new (n || e)(R(Tl)) }, e.\u0275mod = Cn({ type: e }), e.\u0275inj = on({}), e })(), gs = null; function Rn() { return gs } const wt = new Z("DocumentToken"); let Qn = (() => { class e { historyGo(n) { throw new Error("Not implemented") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = W({ token: e, factory: function () { return function VI() { return R(Hm) }() }, providedIn: "platform" }), e })(); const HI = new Z("Location Initialized"); let Hm = (() => { class e extends Qn { constructor(n) { super(), this._doc = n, this._init() } _init() { this.location = window.location, this._history = window.history } getBaseHrefFromDOM() { return Rn().getBaseHref(this._doc) } onPopState(n) { const r = Rn().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("popstate", n, !1), () => r.removeEventListener("popstate", n) } onHashChange(n) { const r = Rn().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("hashchange", n, !1), () => r.removeEventListener("hashchange", n) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(n) { this.location.pathname = n } pushState(n, r, i) { Um() ? this._history.pushState(n, r, i) : this.location.hash = i } replaceState(n, r, i) { Um() ? this._history.replaceState(n, r, i) : this.location.hash = i } forward() { this._history.forward() } back() { this._history.back() } historyGo(n = 0) { this._history.go(n) } getState() { return this._history.state } } return e.\u0275fac = function (n) { return new (n || e)(R(wt)) }, e.\u0275prov = W({ token: e, factory: function () { return function UI() { return new Hm(R(wt)) }() }, providedIn: "platform" }), e })(); function Um() { return !!window.history.pushState } function Nl(e, t) { if (0 == e.length) return t; if (0 == t.length) return e; let n = 0; return e.endsWith("/") && n++, t.startsWith("/") && n++, 2 == n ? e + t.substring(1) : 1 == n ? e + t : e + "/" + t } function $m(e) { const t = e.match(/#|\?|$/), n = t && t.index || e.length; return e.slice(0, n - ("/" === e[n - 1] ? 1 : 0)) + e.slice(n) } function hn(e) { return e && "?" !== e[0] ? "?" + e : e } let $r = (() => { class e { historyGo(n) { throw new Error("Not implemented") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = W({ token: e, factory: function () { return function $I(e) { const t = R(wt).location; return new zm(R(Qn), t && t.origin || "") }() }, providedIn: "root" }), e })(); const Fl = new Z("appBaseHref"); let zm = (() => { class e extends $r { constructor(n, r) { if (super(), this._platformLocation = n, this._removeListenerFns = [], null == r && (r = this._platformLocation.getBaseHrefFromDOM()), null == r) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = r } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } prepareExternalUrl(n) { return Nl(this._baseHref, n) } path(n = !1) { const r = this._platformLocation.pathname + hn(this._platformLocation.search), i = this._platformLocation.hash; return i && n ? `${r}${i}` : r } pushState(n, r, i, o) { const s = this.prepareExternalUrl(i + hn(o)); this._platformLocation.pushState(n, r, s) } replaceState(n, r, i, o) { const s = this.prepareExternalUrl(i + hn(o)); this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(n = 0) { var r, i; null === (i = (r = this._platformLocation).historyGo) || void 0 === i || i.call(r, n) } } return e.\u0275fac = function (n) { return new (n || e)(R(Qn), R(Fl, 8)) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac }), e })(), zI = (() => { class e extends $r { constructor(n, r) { super(), this._platformLocation = n, this._baseHref = "", this._removeListenerFns = [], null != r && (this._baseHref = r) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } path(n = !1) { let r = this._platformLocation.hash; return null == r && (r = "#"), r.length > 0 ? r.substring(1) : r } prepareExternalUrl(n) { const r = Nl(this._baseHref, n); return r.length > 0 ? "#" + r : r } pushState(n, r, i, o) { let s = this.prepareExternalUrl(i + hn(o)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(n, r, s) } replaceState(n, r, i, o) { let s = this.prepareExternalUrl(i + hn(o)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(n = 0) { var r, i; null === (i = (r = this._platformLocation).historyGo) || void 0 === i || i.call(r, n) } } return e.\u0275fac = function (n) { return new (n || e)(R(Qn), R(Fl, 8)) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac }), e })(), kl = (() => { class e { constructor(n, r) { this._subject = new Je, this._urlChangeListeners = [], this._platformStrategy = n; const i = this._platformStrategy.getBaseHref(); this._platformLocation = r, this._baseHref = $m(qm(i)), this._platformStrategy.onPopState(o => { this._subject.emit({ url: this.path(!0), pop: !0, state: o.state, type: o.type }) }) } path(n = !1) { return this.normalize(this._platformStrategy.path(n)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(n, r = "") { return this.path() == this.normalize(n + hn(r)) } normalize(n) { return e.stripTrailingSlash(function GI(e, t) { return e && t.startsWith(e) ? t.substring(e.length) : t }(this._baseHref, qm(n))) } prepareExternalUrl(n) { return n && "/" !== n[0] && (n = "/" + n), this._platformStrategy.prepareExternalUrl(n) } go(n, r = "", i = null) { this._platformStrategy.pushState(i, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + hn(r)), i) } replaceState(n, r = "", i = null) { this._platformStrategy.replaceState(i, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + hn(r)), i) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } historyGo(n = 0) { var r, i; null === (i = (r = this._platformStrategy).historyGo) || void 0 === i || i.call(r, n) } onUrlChange(n) { this._urlChangeListeners.push(n), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(r => { this._notifyUrlChangeListeners(r.url, r.state) })) } _notifyUrlChangeListeners(n = "", r) { this._urlChangeListeners.forEach(i => i(n, r)) } subscribe(n, r, i) { return this._subject.subscribe({ next: n, error: r, complete: i }) } } return e.normalizeQueryParams = hn, e.joinWithSlash = Nl, e.stripTrailingSlash = $m, e.\u0275fac = function (n) { return new (n || e)(R($r), R(Qn)) }, e.\u0275prov = W({ token: e, factory: function () { return function qI() { return new kl(R($r), R(Qn)) }() }, providedIn: "root" }), e })(); function qm(e) { return e.replace(/\/index.html$/, "") } let uS = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = Cn({ type: e }), e.\u0275inj = on({}), e })(); let fS = (() => { class e { } return e.\u0275prov = W({ token: e, providedIn: "root", factory: () => new hS(R(wt), window) }), e })(); class hS { constructor(t, n) { this.document = t, this.window = n, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (!this.supportsScrolling()) return; const n = function pS(e, t) { const n = e.getElementById(t) || e.getElementsByName(t)[0]; if (n) return n; if ("function" == typeof e.createTreeWalker && e.body && (e.body.createShadowRoot || e.body.attachShadow)) { const r = e.createTreeWalker(e.body, NodeFilter.SHOW_ELEMENT); let i = r.currentNode; for (; i;) { const o = i.shadowRoot; if (o) { const s = o.getElementById(t) || o.querySelector(`[name="${t}"]`); if (s) return s } i = r.nextNode() } } return null }(this.document, t); n && (this.scrollToElement(n), n.focus()) } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const n = this.window.history; n && n.scrollRestoration && (n.scrollRestoration = t) } } scrollToElement(t) { const n = t.getBoundingClientRect(), r = n.left + this.window.pageXOffset, i = n.top + this.window.pageYOffset, o = this.offset(); this.window.scrollTo(r - o[0], i - o[1]) } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const t = oy(this.window.history) || oy(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch (t) { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch (t) { return !1 } } } function oy(e) { return Object.getOwnPropertyDescriptor(e, "scrollRestoration") } class Yl extends class mS extends class BI { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { !function jI(e) { gs || (gs = e) }(new Yl) } onAndCancel(t, n, r) { return t.addEventListener(n, r, !1), () => { t.removeEventListener(n, r, !1) } } dispatchEvent(t, n) { t.dispatchEvent(n) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, n) { return (n = n || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, n) { return "window" === n ? window : "document" === n ? t : "body" === n ? t.body : null } getBaseHref(t) { const n = function yS() { return zi = zi || document.querySelector("base"), zi ? zi.getAttribute("href") : null }(); return null == n ? null : function vS(e) { Ms = Ms || document.createElement("a"), Ms.setAttribute("href", e); const t = Ms.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(n) } resetBaseElement() { zi = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return function AT(e, t) { t = encodeURIComponent(t); for (const n of e.split(";")) { const r = n.indexOf("="), [i, o] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (i.trim() === t) return decodeURIComponent(o) } return null }(document.cookie, t) } } let Ms, zi = null; const sy = new Z("TRANSITION_ID"), CS = [{ provide: vl, useFactory: function DS(e, t, n) { return () => { n.get(Dl).donePromise.then(() => { const r = Rn(), i = t.querySelectorAll(`style[ng-transition="${e}"]`); for (let o = 0; o < i.length; o++)r.remove(i[o]) }) } }, deps: [sy, wt, dt], multi: !0 }]; class Kl { static init() { !function dI(e) { Ml = e }(new Kl) } addToWindow(t) { X.getAngularTestability = (r, i = !0) => { const o = t.findTestabilityInTree(r, i); if (null == o) throw new Error("Could not find testability for element."); return o }, X.getAllAngularTestabilities = () => t.getAllTestabilities(), X.getAllAngularRootElements = () => t.getAllRootElements(), X.frameworkStabilizers || (X.frameworkStabilizers = []), X.frameworkStabilizers.push(r => { const i = X.getAllAngularTestabilities(); let o = i.length, s = !1; const a = function (u) { s = s || u, o--, 0 == o && r(s) }; i.forEach(function (u) { u.whenStable(a) }) }) } findTestabilityInTree(t, n, r) { if (null == n) return null; const i = t.getTestability(n); return null != i ? i : r ? Rn().isShadowRoot(n) ? this.findTestabilityInTree(t, n.host, !0) : this.findTestabilityInTree(t, n.parentElement, !0) : null } } let _S = (() => { class e { build() { return new XMLHttpRequest } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac }), e })(); const Is = new Z("EventManagerPlugins"); let Ts = (() => { class e { constructor(n, r) { this._zone = r, this._eventNameToPlugin = new Map, n.forEach(i => i.manager = this), this._plugins = n.slice().reverse() } addEventListener(n, r, i) { return this._findPluginFor(r).addEventListener(n, r, i) } addGlobalEventListener(n, r, i) { return this._findPluginFor(r).addGlobalEventListener(n, r, i) } getZone() { return this._zone } _findPluginFor(n) { const r = this._eventNameToPlugin.get(n); if (r) return r; const i = this._plugins; for (let o = 0; o < i.length; o++) { const s = i[o]; if (s.supports(n)) return this._eventNameToPlugin.set(n, s), s } throw new Error(`No event manager plugin found for event ${n}`) } } return e.\u0275fac = function (n) { return new (n || e)(R(Is), R(Le)) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac }), e })(); class ay { constructor(t) { this._doc = t } addGlobalEventListener(t, n, r) { const i = Rn().getGlobalEventTarget(this._doc, t); if (!i) throw new Error(`Unsupported event target ${i} for event ${n}`); return this.addEventListener(i, n, r) } } let uy = (() => { class e { constructor() { this._stylesSet = new Set } addStyles(n) { const r = new Set; n.forEach(i => { this._stylesSet.has(i) || (this._stylesSet.add(i), r.add(i)) }), this.onStylesAdded(r) } onStylesAdded(n) { } getAllStyles() { return Array.from(this._stylesSet) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac }), e })(), qi = (() => { class e extends uy { constructor(n) { super(), this._doc = n, this._hostNodes = new Map, this._hostNodes.set(n.head, []) } _addStylesToHost(n, r, i) { n.forEach(o => { const s = this._doc.createElement("style"); s.textContent = o, i.push(r.appendChild(s)) }) } addHost(n) { const r = []; this._addStylesToHost(this._stylesSet, n, r), this._hostNodes.set(n, r) } removeHost(n) { const r = this._hostNodes.get(n); r && r.forEach(ly), this._hostNodes.delete(n) } onStylesAdded(n) { this._hostNodes.forEach((r, i) => { this._addStylesToHost(n, i, r) }) } ngOnDestroy() { this._hostNodes.forEach(n => n.forEach(ly)) } } return e.\u0275fac = function (n) { return new (n || e)(R(wt)) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac }), e })(); function ly(e) { Rn().remove(e) } const Jl = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, Xl = /%COMP%/g; function Ss(e, t, n) { for (let r = 0; r < t.length; r++) { let i = t[r]; Array.isArray(i) ? Ss(e, i, n) : (i = i.replace(Xl, e), n.push(i)) } return n } function fy(e) { return t => { if ("__ngUnwrap__" === t) return e; !1 === e(t) && (t.preventDefault(), t.returnValue = !1) } } let ec = (() => { class e { constructor(n, r, i) { this.eventManager = n, this.sharedStylesHost = r, this.appId = i, this.rendererByCompId = new Map, this.defaultRenderer = new tc(n) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; switch (r.encapsulation) { case Bt.Emulated: { let i = this.rendererByCompId.get(r.id); return i || (i = new TS(this.eventManager, this.sharedStylesHost, r, this.appId), this.rendererByCompId.set(r.id, i)), i.applyToHost(n), i } case 1: case Bt.ShadowDom: return new SS(this.eventManager, this.sharedStylesHost, n, r); default: if (!this.rendererByCompId.has(r.id)) { const i = Ss(r.id, r.styles, []); this.sharedStylesHost.addStyles(i), this.rendererByCompId.set(r.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return e.\u0275fac = function (n) { return new (n || e)(R(Ts), R(qi), R(Vi)) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac }), e })(); class tc { constructor(t) { this.eventManager = t, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(t, n) { return n ? document.createElementNS(Jl[n] || n, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, n) { t.appendChild(n) } insertBefore(t, n, r) { t && t.insertBefore(n, r) } removeChild(t, n) { t && t.removeChild(n) } selectRootElement(t, n) { let r = "string" == typeof t ? document.querySelector(t) : t; if (!r) throw new Error(`The selector "${t}" did not match any elements`); return n || (r.textContent = ""), r } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, n, r, i) { if (i) { n = i + ":" + n; const o = Jl[i]; o ? t.setAttributeNS(o, n, r) : t.setAttribute(n, r) } else t.setAttribute(n, r) } removeAttribute(t, n, r) { if (r) { const i = Jl[r]; i ? t.removeAttributeNS(i, n) : t.removeAttribute(`${r}:${n}`) } else t.removeAttribute(n) } addClass(t, n) { t.classList.add(n) } removeClass(t, n) { t.classList.remove(n) } setStyle(t, n, r, i) { i & (lt.DashCase | lt.Important) ? t.style.setProperty(n, r, i & lt.Important ? "important" : "") : t.style[n] = r } removeStyle(t, n, r) { r & lt.DashCase ? t.style.removeProperty(n) : t.style[n] = "" } setProperty(t, n, r) { t[n] = r } setValue(t, n) { t.nodeValue = n } listen(t, n, r) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, n, fy(r)) : this.eventManager.addEventListener(t, n, fy(r)) } } class TS extends tc { constructor(t, n, r, i) { super(t), this.component = r; const o = Ss(i + "-" + r.id, r.styles, []); n.addStyles(o), this.contentAttr = function bS(e) { return "_ngcontent-%COMP%".replace(Xl, e) }(i + "-" + r.id), this.hostAttr = function MS(e) { return "_nghost-%COMP%".replace(Xl, e) }(i + "-" + r.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, n) { const r = super.createElement(t, n); return super.setAttribute(r, this.contentAttr, ""), r } } class SS extends tc { constructor(t, n, r, i) { super(t), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const o = Ss(i.id, i.styles, []); for (let s = 0; s < o.length; s++) { const a = document.createElement("style"); a.textContent = o[s], this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, n) { return super.appendChild(this.nodeOrShadowRoot(t), n) } insertBefore(t, n, r) { return super.insertBefore(this.nodeOrShadowRoot(t), n, r) } removeChild(t, n) { return super.removeChild(this.nodeOrShadowRoot(t), n) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let AS = (() => { class e extends ay { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, i) { return n.addEventListener(r, i, !1), () => this.removeEventListener(n, r, i) } removeEventListener(n, r, i) { return n.removeEventListener(r, i) } } return e.\u0275fac = function (n) { return new (n || e)(R(wt)) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac }), e })(); const py = ["alt", "control", "meta", "shift"], RS = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, gy = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, PS = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; let OS = (() => { class e extends ay { constructor(n) { super(n) } supports(n) { return null != e.parseEventName(n) } addEventListener(n, r, i) { const o = e.parseEventName(r), s = e.eventCallback(o.fullKey, i, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Rn().onAndCancel(n, o.domEventName, s)) } static parseEventName(n) { const r = n.toLowerCase().split("."), i = r.shift(); if (0 === r.length || "keydown" !== i && "keyup" !== i) return null; const o = e._normalizeKey(r.pop()); let s = ""; if (py.forEach(u => { const l = r.indexOf(u); l > -1 && (r.splice(l, 1), s += u + ".") }), s += o, 0 != r.length || 0 === o.length) return null; const a = {}; return a.domEventName = i, a.fullKey = s, a } static getEventFullKey(n) { let r = "", i = function NS(e) { let t = e.key; if (null == t) { if (t = e.keyIdentifier, null == t) return "Unidentified"; t.startsWith("U+") && (t = String.fromCharCode(parseInt(t.substring(2), 16)), 3 === e.location && gy.hasOwnProperty(t) && (t = gy[t])) } return RS[t] || t }(n); return i = i.toLowerCase(), " " === i ? i = "space" : "." === i && (i = "dot"), py.forEach(o => { o != i && PS[o](n) && (r += o + ".") }), r += i, r } static eventCallback(n, r, i) { return o => { e.getEventFullKey(o) === n && i.runGuarded(() => r(o)) } } static _normalizeKey(n) { return "esc" === n ? "escape" : n } } return e.\u0275fac = function (n) { return new (n || e)(R(wt)) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac }), e })(); const jS = Im(FI, "browser", [{ provide: vm, useValue: "browser" }, { provide: ym, useValue: function FS() { Yl.makeCurrent(), Kl.init() }, multi: !0 }, { provide: wt, useFactory: function LS() { return function ND(e) { pa = e }(document), document }, deps: [] }]), BS = [{ provide: Au, useValue: "root" }, { provide: wi, useFactory: function kS() { return new wi }, deps: [] }, { provide: Is, useClass: AS, multi: !0, deps: [wt, Le, vm] }, { provide: Is, useClass: OS, multi: !0, deps: [wt] }, { provide: ec, useClass: ec, deps: [Ts, qi, Vi] }, { provide: Og, useExisting: ec }, { provide: uy, useExisting: qi }, { provide: qi, useClass: qi, deps: [wt] }, { provide: bl, useClass: bl, deps: [Le] }, { provide: Ts, useClass: Ts, deps: [Is, Le] }, { provide: class gS { }, useClass: _S, deps: [] }]; let my = (() => { class e { constructor(n) { if (n) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(n) { return { ngModule: e, providers: [{ provide: Vi, useValue: n.appId }, { provide: sy, useExisting: Vi }, CS] } } } return e.\u0275fac = function (n) { return new (n || e)(R(e, 12)) }, e.\u0275mod = Cn({ type: e }), e.\u0275inj = on({ providers: BS, imports: [uS, kI] }), e })(); function V(...e) { return Fe(e, Xr(e)) } "undefined" != typeof window && window; class jt extends Xt { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const n = super._subscribe(t); return !n.closed && t.next(this._value), n } getValue() { const { hasError: t, thrownError: n, _value: r } = this; if (t) throw n; return this._throwIfClosed(), r } next(t) { super.next(this._value = t) } } const { isArray: YS } = Array, { getPrototypeOf: KS, prototype: JS, keys: XS } = Object; const { isArray: nA } = Array; function sA(...e) { const t = Xr(e), n = function Zv(e) { return k(Ys(e)) ? e.pop() : void 0 }(e), { args: r, keys: i } = function eA(e) { if (1 === e.length) { const t = e[0]; if (YS(t)) return { args: t, keys: null }; if (function tA(e) { return e && "object" == typeof e && KS(e) === JS }(t)) { const n = XS(t); return { args: n.map(r => t[r]), keys: n } } } return { args: e, keys: null } }(e); if (0 === r.length) return Fe([], t); const o = new Me(function aA(e, t, n = Fn) { return r => { Dy(t, () => { const { length: i } = e, o = new Array(i); let s = i, a = i; for (let u = 0; u < i; u++)Dy(t, () => { const l = Fe(e[u], t); let c = !1; l.subscribe(Ne(r, d => { o[u] = d, c || (c = !0, a--), a || r.next(n(o.slice())) }, () => { --s || r.complete() })) }, r) }, r) } }(r, t, i ? s => function oA(e, t) { return e.reduce((n, r, i) => (n[r] = t[i], n), {}) }(i, s) : Fn)); return n ? o.pipe(function iA(e) { return de(t => function rA(e, t) { return nA(t) ? e(...t) : e(t) }(e, t)) }(n)) : o } function Dy(e, t, n) { e ? tn(n, e, t) : t() } function As(e, t) { const n = k(e) ? e : () => e, r = i => i.error(n()); return new Me(t ? i => t.schedule(r, 0, i) : r) } const xs = ie(e => function () { e(this), this.name = "EmptyError", this.message = "no elements in sequence" }); function rc(...e) { return function uA() { return Jr(1) }()(Fe(e, Xr(e))) } function Cy(e) { return new Me(t => { en(e()).subscribe(t) }) } function _y() { return Oe((e, t) => { let n = null; e._refCount++; const r = Ne(t, void 0, void 0, void 0, () => { if (!e || e._refCount <= 0 || 0 < --e._refCount) return void (n = null); const i = e._connection, o = n; n = null, i && (!o || i === o) && i.unsubscribe(), t.unsubscribe() }); e.subscribe(r), r.closed || (n = e.connect()) }) } class lA extends Me { constructor(t, n) { super(), this.source = t, this.subjectFactory = n, this._subject = null, this._refCount = 0, this._connection = null, Bc(t) && (this.lift = t.lift) } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: t } = this; this._subject = this._connection = null, null == t || t.unsubscribe() } connect() { let t = this._connection; if (!t) { t = this._connection = new oe; const n = this.getSubject(); t.add(this.source.subscribe(Ne(n, void 0, () => { this._teardown(), n.complete() }, r => { this._teardown(), n.error(r) }, () => this._teardown()))), t.closed && (this._connection = null, t = oe.EMPTY) } return t } refCount() { return _y()(this) } } function Zn(e, t) { return Oe((n, r) => { let i = null, o = 0, s = !1; const a = () => s && !i && r.complete(); n.subscribe(Ne(r, u => { null == i || i.unsubscribe(); let l = 0; const c = o++; en(e(u, c)).subscribe(i = Ne(r, d => r.next(t ? t(u, d, c, l++) : d), () => { i = null, a() })) }, () => { s = !0, a() })) }) } function dA(e, t, n, r, i) { return (o, s) => { let a = n, u = t, l = 0; o.subscribe(Ne(s, c => { const d = l++; u = a ? e(u, c, d) : (a = !0, c), r && s.next(u) }, i && (() => { a && s.next(u), s.complete() }))) } } function wy(e, t) { return Oe(dA(e, t, arguments.length >= 2, !0)) } function zr(e, t) { return Oe((n, r) => { let i = 0; n.subscribe(Ne(r, o => e.call(t, o, i++) && r.next(o))) }) } function On(e) { return Oe((t, n) => { let o, r = null, i = !1; r = t.subscribe(Ne(n, void 0, void 0, s => { o = en(e(s, On(e)(t))), r ? (r.unsubscribe(), r = null, o.subscribe(n)) : i = !0 })), i && (r.unsubscribe(), r = null, o.subscribe(n)) }) } function Gi(e, t) { return k(t) ? xe(e, t, 1) : xe(e, 1) } function ic(e) { return e <= 0 ? () => nn : Oe((t, n) => { let r = []; t.subscribe(Ne(n, i => { r.push(i), e < r.length && r.shift() }, () => { for (const i of r) n.next(i); n.complete() }, void 0, () => { r = null })) }) } function Ey(e = fA) { return Oe((t, n) => { let r = !1; t.subscribe(Ne(n, i => { r = !0, n.next(i) }, () => r ? n.complete() : n.error(e()))) }) } function fA() { return new xs } function by(e) { return Oe((t, n) => { let r = !1; t.subscribe(Ne(n, i => { r = !0, n.next(i) }, () => { r || n.next(e), n.complete() })) }) } function qr(e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? zr((i, o) => e(i, o, r)) : Fn, so(1), n ? by(t) : Ey(() => new xs)) } function ft(e, t, n) { const r = k(e) || t || n ? { next: e, error: t, complete: n } : e; return r ? Oe((i, o) => { var s; null === (s = r.subscribe) || void 0 === s || s.call(r); let a = !0; i.subscribe(Ne(o, u => { var l; null === (l = r.next) || void 0 === l || l.call(r, u), o.next(u) }, () => { var u; a = !1, null === (u = r.complete) || void 0 === u || u.call(r), o.complete() }, u => { var l; a = !1, null === (l = r.error) || void 0 === l || l.call(r, u), o.error(u) }, () => { var u, l; a && (null === (u = r.unsubscribe) || void 0 === u || u.call(r)), null === (l = r.finalize) || void 0 === l || l.call(r) })) }) : Fn } class gn { constructor(t, n) { this.id = t, this.url = n } } class oc extends gn { constructor(t, n, r = "imperative", i = null) { super(t, n), this.navigationTrigger = r, this.restoredState = i } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Wi extends gn { constructor(t, n, r) { super(t, n), this.urlAfterRedirects = r } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class My extends gn { constructor(t, n, r) { super(t, n), this.reason = r } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class gA extends gn { constructor(t, n, r) { super(t, n), this.error = r } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class mA extends gn { constructor(t, n, r, i) { super(t, n), this.urlAfterRedirects = r, this.state = i } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class yA extends gn { constructor(t, n, r, i) { super(t, n), this.urlAfterRedirects = r, this.state = i } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class vA extends gn { constructor(t, n, r, i, o) { super(t, n), this.urlAfterRedirects = r, this.state = i, this.shouldActivate = o } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class DA extends gn { constructor(t, n, r, i) { super(t, n), this.urlAfterRedirects = r, this.state = i } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class CA extends gn { constructor(t, n, r, i) { super(t, n), this.urlAfterRedirects = r, this.state = i } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Iy { constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class Ty { constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class _A { constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class wA { constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class EA { constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class bA { constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Sy { constructor(t, n, r) { this.routerEvent = t, this.position = n, this.anchor = r } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } const $ = "primary"; class MA { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const n = this.params[t]; return Array.isArray(n) ? n[0] : n } return null } getAll(t) { if (this.has(t)) { const n = this.params[t]; return Array.isArray(n) ? n : [n] } return [] } get keys() { return Object.keys(this.params) } } function Gr(e) { return new MA(e) } const Ay = "ngNavigationCancelingError"; function sc(e) { const t = Error("NavigationCancelingError: " + e); return t[Ay] = !0, t } function TA(e, t, n) { const r = n.path.split("/"); if (r.length > e.length || "full" === n.pathMatch && (t.hasChildren() || r.length < e.length)) return null; const i = {}; for (let o = 0; o < r.length; o++) { const s = r[o], a = e[o]; if (s.startsWith(":")) i[s.substring(1)] = a; else if (s !== a.path) return null } return { consumed: e.slice(0, r.length), posParams: i } } function Yt(e, t) { const n = e ? Object.keys(e) : void 0, r = t ? Object.keys(t) : void 0; if (!n || !r || n.length != r.length) return !1; let i; for (let o = 0; o < n.length; o++)if (i = n[o], !xy(e[i], t[i])) return !1; return !0 } function xy(e, t) { if (Array.isArray(e) && Array.isArray(t)) { if (e.length !== t.length) return !1; const n = [...e].sort(), r = [...t].sort(); return n.every((i, o) => r[o] === i) } return e === t } function Ry(e) { return Array.prototype.concat.apply([], e) } function Py(e) { return e.length > 0 ? e[e.length - 1] : null } function je(e, t) { for (const n in e) e.hasOwnProperty(n) && t(e[n], n) } function Kt(e) { return cp(e) ? e : Yo(e) ? Fe(Promise.resolve(e)) : V(e) } const xA = { exact: function Fy(e, t, n) { if (!Kn(e.segments, t.segments) || !Rs(e.segments, t.segments, n) || e.numberOfChildren !== t.numberOfChildren) return !1; for (const r in t.children) if (!e.children[r] || !Fy(e.children[r], t.children[r], n)) return !1; return !0 }, subset: ky }, Oy = { exact: function RA(e, t) { return Yt(e, t) }, subset: function PA(e, t) { return Object.keys(t).length <= Object.keys(e).length && Object.keys(t).every(n => xy(e[n], t[n])) }, ignored: () => !0 }; function Ny(e, t, n) { return xA[n.paths](e.root, t.root, n.matrixParams) && Oy[n.queryParams](e.queryParams, t.queryParams) && !("exact" === n.fragment && e.fragment !== t.fragment) } function ky(e, t, n) { return Ly(e, t, t.segments, n) } function Ly(e, t, n, r) { if (e.segments.length > n.length) { const i = e.segments.slice(0, n.length); return !(!Kn(i, n) || t.hasChildren() || !Rs(i, n, r)) } if (e.segments.length === n.length) { if (!Kn(e.segments, n) || !Rs(e.segments, n, r)) return !1; for (const i in t.children) if (!e.children[i] || !ky(e.children[i], t.children[i], r)) return !1; return !0 } { const i = n.slice(0, e.segments.length), o = n.slice(e.segments.length); return !!(Kn(e.segments, i) && Rs(e.segments, i, r) && e.children[$]) && Ly(e.children[$], t, o, r) } } function Rs(e, t, n) { return t.every((r, i) => Oy[n](e[i].parameters, r.parameters)) } class Yn { constructor(t, n, r) { this.root = t, this.queryParams = n, this.fragment = r } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Gr(this.queryParams)), this._queryParamMap } toString() { return FA.serialize(this) } } class q { constructor(t, n) { this.segments = t, this.children = n, this.parent = null, je(n, (r, i) => r.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Ps(this) } } class Qi { constructor(t, n) { this.path = t, this.parameters = n } get parameterMap() { return this._parameterMap || (this._parameterMap = Gr(this.parameters)), this._parameterMap } toString() { return Uy(this) } } function Kn(e, t) { return e.length === t.length && e.every((n, r) => n.path === t[r].path) } class jy { } class By { parse(t) { const n = new zA(t); return new Yn(n.parseRootSegment(), n.parseQueryParams(), n.parseFragment()) } serialize(t) { const n = `/${Zi(t.root, !0)}`, r = function jA(e) { const t = Object.keys(e).map(n => { const r = e[n]; return Array.isArray(r) ? r.map(i => `${Os(n)}=${Os(i)}`).join("&") : `${Os(n)}=${Os(r)}` }).filter(n => !!n); return t.length ? `?${t.join("&")}` : "" }(t.queryParams); return `${n}${r}${"string" == typeof t.fragment ? `#${function kA(e) { return encodeURI(e) }(t.fragment)}` : ""}` } } const FA = new By; function Ps(e) { return e.segments.map(t => Uy(t)).join("/") } function Zi(e, t) { if (!e.hasChildren()) return Ps(e); if (t) { const n = e.children[$] ? Zi(e.children[$], !1) : "", r = []; return je(e.children, (i, o) => { o !== $ && r.push(`${o}:${Zi(i, !1)}`) }), r.length > 0 ? `${n}(${r.join("//")})` : n } { const n = function NA(e, t) { let n = []; return je(e.children, (r, i) => { i === $ && (n = n.concat(t(r, i))) }), je(e.children, (r, i) => { i !== $ && (n = n.concat(t(r, i))) }), n }(e, (r, i) => i === $ ? [Zi(e.children[$], !1)] : [`${i}:${Zi(r, !1)}`]); return 1 === Object.keys(e.children).length && null != e.children[$] ? `${Ps(e)}/${n[0]}` : `${Ps(e)}/(${n.join("//")})` } } function Vy(e) { return encodeURIComponent(e).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Os(e) { return Vy(e).replace(/%3B/gi, ";") } function ac(e) { return Vy(e).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function Ns(e) { return decodeURIComponent(e) } function Hy(e) { return Ns(e.replace(/\+/g, "%20")) } function Uy(e) { return `${ac(e.path)}${function LA(e) { return Object.keys(e).map(t => `;${ac(t)}=${ac(e[t])}`).join("") }(e.parameters)}` } const BA = /^[^\/()?;=#]+/; function Fs(e) { const t = e.match(BA); return t ? t[0] : "" } const VA = /^[^=?&#]+/, UA = /^[^&#]+/; class zA { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new q([], {}) : new q([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let n = {}; this.peekStartsWith("/(") && (this.capture("/"), n = this.parseParens(!0)); let r = {}; return this.peekStartsWith("(") && (r = this.parseParens(!1)), (t.length > 0 || Object.keys(n).length > 0) && (r[$] = new q(t, n)), r } parseSegment() { const t = Fs(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(t), new Qi(Ns(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const n = Fs(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const i = Fs(this.remaining); i && (r = i, this.capture(r)) } t[Ns(n)] = Ns(r) } parseQueryParam(t) { const n = function HA(e) { const t = e.match(VA); return t ? t[0] : "" }(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const s = function $A(e) { const t = e.match(UA); return t ? t[0] : "" }(this.remaining); s && (r = s, this.capture(r)) } const i = Hy(n), o = Hy(r); if (t.hasOwnProperty(i)) { let s = t[i]; Array.isArray(s) || (s = [s], t[i] = s), s.push(o) } else t[i] = o } parseParens(t) { const n = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const r = Fs(this.remaining), i = this.remaining[r.length]; if ("/" !== i && ")" !== i && ";" !== i) throw new Error(`Cannot parse url '${this.url}'`); let o; r.indexOf(":") > -1 ? (o = r.substr(0, r.indexOf(":")), this.capture(o), this.capture(":")) : t && (o = $); const s = this.parseChildren(); n[o] = 1 === Object.keys(s).length ? s[$] : new q([], s), this.consumeOptional("//") } return n } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`) } } class $y { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const n = this.pathFromRoot(t); return n.length > 1 ? n[n.length - 2] : null } children(t) { const n = uc(t, this._root); return n ? n.children.map(r => r.value) : [] } firstChild(t) { const n = uc(t, this._root); return n && n.children.length > 0 ? n.children[0].value : null } siblings(t) { const n = lc(t, this._root); return n.length < 2 ? [] : n[n.length - 2].children.map(i => i.value).filter(i => i !== t) } pathFromRoot(t) { return lc(t, this._root).map(n => n.value) } } function uc(e, t) { if (e === t.value) return t; for (const n of t.children) { const r = uc(e, n); if (r) return r } return null } function lc(e, t) { if (e === t.value) return [t]; for (const n of t.children) { const r = lc(e, n); if (r.length) return r.unshift(t), r } return [] } class mn { constructor(t, n) { this.value = t, this.children = n } toString() { return `TreeNode(${this.value})` } } function Wr(e) { const t = {}; return e && e.children.forEach(n => t[n.value.outlet] = n), t } class zy extends $y { constructor(t, n) { super(t), this.snapshot = n, cc(this, t) } toString() { return this.snapshot.toString() } } function qy(e, t) { const n = function qA(e, t) { const s = new ks([], {}, {}, "", {}, $, t, null, e.root, -1, {}); return new Wy("", new mn(s, [])) }(e, t), r = new jt([new Qi("", {})]), i = new jt({}), o = new jt({}), s = new jt({}), a = new jt(""), u = new Qr(r, i, s, a, o, $, t, n.root); return u.snapshot = n.root, new zy(new mn(u, []), n) } class Qr { constructor(t, n, r, i, o, s, a, u) { this.url = t, this.params = n, this.queryParams = r, this.fragment = i, this.data = o, this.outlet = s, this.component = a, this._futureSnapshot = u } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(de(t => Gr(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(de(t => Gr(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function Gy(e, t = "emptyOnly") { const n = e.pathFromRoot; let r = 0; if ("always" !== t) for (r = n.length - 1; r >= 1;) { const i = n[r], o = n[r - 1]; if (i.routeConfig && "" === i.routeConfig.path) r--; else { if (o.component) break; r-- } } return function GA(e) { return e.reduce((t, n) => ({ params: Object.assign(Object.assign({}, t.params), n.params), data: Object.assign(Object.assign({}, t.data), n.data), resolve: Object.assign(Object.assign({}, t.resolve), n._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class ks { constructor(t, n, r, i, o, s, a, u, l, c, d) { this.url = t, this.params = n, this.queryParams = r, this.fragment = i, this.data = o, this.outlet = s, this.component = a, this.routeConfig = u, this._urlSegment = l, this._lastPathIndex = c, this._resolve = d } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Gr(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Gr(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(r => r.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class Wy extends $y { constructor(t, n) { super(n), this.url = t, cc(this, n) } toString() { return Qy(this._root) } } function cc(e, t) { t.value._routerState = e, t.children.forEach(n => cc(e, n)) } function Qy(e) { const t = e.children.length > 0 ? ` { ${e.children.map(Qy).join(", ")} } ` : ""; return `${e.value}${t}` } function dc(e) { if (e.snapshot) { const t = e.snapshot, n = e._futureSnapshot; e.snapshot = n, Yt(t.queryParams, n.queryParams) || e.queryParams.next(n.queryParams), t.fragment !== n.fragment && e.fragment.next(n.fragment), Yt(t.params, n.params) || e.params.next(n.params), function SA(e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; ++n)if (!Yt(e[n], t[n])) return !1; return !0 }(t.url, n.url) || e.url.next(n.url), Yt(t.data, n.data) || e.data.next(n.data) } else e.snapshot = e._futureSnapshot, e.data.next(e._futureSnapshot.data) } function fc(e, t) { const n = Yt(e.params, t.params) && function OA(e, t) { return Kn(e, t) && e.every((n, r) => Yt(n.parameters, t[r].parameters)) }(e.url, t.url); return n && !(!e.parent != !t.parent) && (!e.parent || fc(e.parent, t.parent)) } function Yi(e, t, n) { if (n && e.shouldReuseRoute(t.value, n.value.snapshot)) { const r = n.value; r._futureSnapshot = t.value; const i = function QA(e, t, n) { return t.children.map(r => { for (const i of n.children) if (e.shouldReuseRoute(r.value, i.value.snapshot)) return Yi(e, r, i); return Yi(e, r) }) }(e, t, n); return new mn(r, i) } { if (e.shouldAttach(t.value)) { const o = e.retrieve(t.value); if (null !== o) { const s = o.route; return s.value._futureSnapshot = t.value, s.children = t.children.map(a => Yi(e, a)), s } } const r = function ZA(e) { return new Qr(new jt(e.url), new jt(e.params), new jt(e.queryParams), new jt(e.fragment), new jt(e.data), e.outlet, e.component, e) }(t.value), i = t.children.map(o => Yi(e, o)); return new mn(r, i) } } function Ls(e) { return "object" == typeof e && null != e && !e.outlets && !e.segmentPath } function Ki(e) { return "object" == typeof e && null != e && e.outlets } function hc(e, t, n, r, i) { let o = {}; if (r && je(r, (a, u) => { o[u] = Array.isArray(a) ? a.map(l => `${l}`) : `${a}` }), e === t) return new Yn(n, o, i); const s = Zy(e, t, n); return new Yn(s, o, i) } function Zy(e, t, n) { const r = {}; return je(e.children, (i, o) => { r[o] = i === t ? n : Zy(i, t, n) }), new q(e.segments, r) } class Yy { constructor(t, n, r) { if (this.isAbsolute = t, this.numberOfDoubleDots = n, this.commands = r, t && r.length > 0 && Ls(r[0])) throw new Error("Root segment cannot have matrix parameters"); const i = r.find(Ki); if (i && i !== Py(r)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class pc { constructor(t, n, r) { this.segmentGroup = t, this.processChildren = n, this.index = r } } function Ky(e, t, n) { if (e || (e = new q([], {})), 0 === e.segments.length && e.hasChildren()) return js(e, t, n); const r = function tx(e, t, n) { let r = 0, i = t; const o = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; i < e.segments.length;) { if (r >= n.length) return o; const s = e.segments[i], a = n[r]; if (Ki(a)) break; const u = `${a}`, l = r < n.length - 1 ? n[r + 1] : null; if (i > 0 && void 0 === u) break; if (u && l && "object" == typeof l && void 0 === l.outlets) { if (!Xy(u, l, s)) return o; r += 2 } else { if (!Xy(u, {}, s)) return o; r++ } i++ } return { match: !0, pathIndex: i, commandIndex: r } }(e, t, n), i = n.slice(r.commandIndex); if (r.match && r.pathIndex < e.segments.length) { const o = new q(e.segments.slice(0, r.pathIndex), {}); return o.children[$] = new q(e.segments.slice(r.pathIndex), e.children), js(o, 0, i) } return r.match && 0 === i.length ? new q(e.segments, {}) : r.match && !e.hasChildren() ? gc(e, t, n) : r.match ? js(e, 0, i) : gc(e, t, n) } function js(e, t, n) { if (0 === n.length) return new q(e.segments, {}); { const r = function ex(e) { return Ki(e[0]) ? e[0].outlets : { [$]: e } }(n), i = {}; return je(r, (o, s) => { "string" == typeof o && (o = [o]), null !== o && (i[s] = Ky(e.children[s], t, o)) }), je(e.children, (o, s) => { void 0 === r[s] && (i[s] = o) }), new q(e.segments, i) } } function gc(e, t, n) { const r = e.segments.slice(0, t); let i = 0; for (; i < n.length;) { const o = n[i]; if (Ki(o)) { const u = nx(o.outlets); return new q(r, u) } if (0 === i && Ls(n[0])) { r.push(new Qi(e.segments[t].path, Jy(n[0]))), i++; continue } const s = Ki(o) ? o.outlets[$] : `${o}`, a = i < n.length - 1 ? n[i + 1] : null; s && a && Ls(a) ? (r.push(new Qi(s, Jy(a))), i += 2) : (r.push(new Qi(s, {})), i++) } return new q(r, {}) } function nx(e) { const t = {}; return je(e, (n, r) => { "string" == typeof n && (n = [n]), null !== n && (t[r] = gc(new q([], {}), 0, n)) }), t } function Jy(e) { const t = {}; return je(e, (n, r) => t[r] = `${n}`), t } function Xy(e, t, n) { return e == n.path && Yt(t, n.parameters) } class ix { constructor(t, n, r, i) { this.routeReuseStrategy = t, this.futureState = n, this.currState = r, this.forwardEvent = i } activate(t) { const n = this.futureState._root, r = this.currState ? this.currState._root : null; this.deactivateChildRoutes(n, r, t), dc(this.futureState.root), this.activateChildRoutes(n, r, t) } deactivateChildRoutes(t, n, r) { const i = Wr(n); t.children.forEach(o => { const s = o.value.outlet; this.deactivateRoutes(o, i[s], r), delete i[s] }), je(i, (o, s) => { this.deactivateRouteAndItsChildren(o, r) }) } deactivateRoutes(t, n, r) { const i = t.value, o = n ? n.value : null; if (i === o) if (i.component) { const s = r.getContext(i.outlet); s && this.deactivateChildRoutes(t, n, s.children) } else this.deactivateChildRoutes(t, n, r); else o && this.deactivateRouteAndItsChildren(n, r) } deactivateRouteAndItsChildren(t, n) { t.value.component && this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, n) : this.deactivateRouteAndOutlet(t, n) } detachAndStoreRouteSubtree(t, n) { const r = n.getContext(t.value.outlet), i = r && t.value.component ? r.children : n, o = Wr(t); for (const s of Object.keys(o)) this.deactivateRouteAndItsChildren(o[s], i); if (r && r.outlet) { const s = r.outlet.detach(), a = r.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: s, route: t, contexts: a }) } } deactivateRouteAndOutlet(t, n) { const r = n.getContext(t.value.outlet), i = r && t.value.component ? r.children : n, o = Wr(t); for (const s of Object.keys(o)) this.deactivateRouteAndItsChildren(o[s], i); r && r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated(), r.attachRef = null, r.resolver = null, r.route = null) } activateChildRoutes(t, n, r) { const i = Wr(n); t.children.forEach(o => { this.activateRoutes(o, i[o.value.outlet], r), this.forwardEvent(new bA(o.value.snapshot)) }), t.children.length && this.forwardEvent(new wA(t.value.snapshot)) } activateRoutes(t, n, r) { const i = t.value, o = n ? n.value : null; if (dc(i), i === o) if (i.component) { const s = r.getOrCreateContext(i.outlet); this.activateChildRoutes(t, n, s.children) } else this.activateChildRoutes(t, n, r); else if (i.component) { const s = r.getOrCreateContext(i.outlet); if (this.routeReuseStrategy.shouldAttach(i.snapshot)) { const a = this.routeReuseStrategy.retrieve(i.snapshot); this.routeReuseStrategy.store(i.snapshot, null), s.children.onOutletReAttached(a.contexts), s.attachRef = a.componentRef, s.route = a.route.value, s.outlet && s.outlet.attach(a.componentRef, a.route.value), dc(a.route.value), this.activateChildRoutes(t, null, s.children) } else { const a = function ox(e) { for (let t = e.parent; t; t = t.parent) { const n = t.routeConfig; if (n && n._loadedConfig) return n._loadedConfig; if (n && n.component) return null } return null }(i.snapshot), u = a ? a.module.componentFactoryResolver : null; s.attachRef = null, s.route = i, s.resolver = u, s.outlet && s.outlet.activateWith(i, u), this.activateChildRoutes(t, null, s.children) } } else this.activateChildRoutes(t, null, r) } } class mc { constructor(t, n) { this.routes = t, this.module = n } } function Nn(e) { return "function" == typeof e } function Jn(e) { return e instanceof Yn } const Ji = Symbol("INITIAL_VALUE"); function Xi() { return Zn(e => sA(e.map(t => t.pipe(so(1), function cA(...e) { const t = Xr(e); return Oe((n, r) => { (t ? rc(e, n, t) : rc(e, n)).subscribe(r) }) }(Ji)))).pipe(wy((t, n) => { let r = !1; return n.reduce((i, o, s) => i !== Ji ? i : (o === Ji && (r = !0), r || !1 !== o && s !== n.length - 1 && !Jn(o) ? i : o), t) }, Ji), zr(t => t !== Ji), de(t => Jn(t) ? t : !0 === t), so(1))) } class dx { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new eo, this.attachRef = null } } class eo { constructor() { this.contexts = new Map } onChildOutletCreated(t, n) { const r = this.getOrCreateContext(t); r.outlet = n, this.contexts.set(t, r) } onChildOutletDestroyed(t) { const n = this.getContext(t); n && (n.outlet = null, n.attachRef = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let n = this.getContext(t); return n || (n = new dx, this.contexts.set(t, n)), n } getContext(t) { return this.contexts.get(t) || null } } let yc = (() => { class e { constructor(n, r, i, o, s) { this.parentContexts = n, this.location = r, this.resolver = i, this.changeDetector = s, this.activated = null, this._activatedRoute = null, this.activateEvents = new Je, this.deactivateEvents = new Je, this.attachEvents = new Je, this.detachEvents = new Je, this.name = o || $, n.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const n = this.parentContexts.getContext(this.name); n && n.route && (n.attachRef ? this.attach(n.attachRef, n.route) : this.activateWith(n.route, n.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const n = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(n.instance), n } attach(n, r) { this.activated = n, this._activatedRoute = r, this.location.insert(n.hostView), this.attachEvents.emit(n.instance) } deactivate() { if (this.activated) { const n = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(n) } } activateWith(n, r) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = n; const s = (r = r || this.resolver).resolveComponentFactory(n._futureSnapshot.routeConfig.component), a = this.parentContexts.getOrCreateContext(this.name).children, u = new fx(n, a, this.location.injector); this.activated = this.location.createComponent(s, this.location.length, u), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return e.\u0275fac = function (n) { return new (n || e)(S(eo), S(Ft), S(Fi), function li(e) { return function fC(e, t) { if ("class" === t) return e.classes; if ("style" === t) return e.styles; const n = e.attrs; if (n) { const r = n.length; let i = 0; for (; i < r;) { const o = n[i]; if (Rd(o)) break; if (0 === o) i += 2; else if ("number" == typeof o) for (i++; i < r && "string" == typeof n[i];)i++; else { if (o === t) return n[i + 1]; i += 2 } } } return null }(Ie(), e) }("name"), S(Al)) }, e.\u0275dir = He({ type: e, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"] }), e })(); class fx { constructor(t, n, r) { this.route = t, this.childContexts = n, this.parent = r } get(t, n) { return t === Qr ? this.route : t === eo ? this.childContexts : this.parent.get(t, n) } } let ev = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Vt({ type: e, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (n, r) { 1 & n && Ye(0, "router-outlet") }, directives: [yc], encapsulation: 2 }), e })(); function tv(e, t = "") { for (let n = 0; n < e.length; n++) { const r = e[n]; hx(r, px(t, r)) } } function hx(e, t) { e.children && tv(e.children, t) } function px(e, t) { return t ? e || t.path ? e && !t.path ? `${e}/` : !e && t.path ? t.path : `${e}/${t.path}` : "" : e } function vc(e) { const t = e.children && e.children.map(vc), n = t ? Object.assign(Object.assign({}, e), { children: t }) : Object.assign({}, e); return !n.component && (t || n.loadChildren) && n.outlet && n.outlet !== $ && (n.component = ev), n } function Mt(e) { return e.outlet || $ } function nv(e, t) { const n = e.filter(r => Mt(r) === t); return n.push(...e.filter(r => Mt(r) !== t)), n } const rv = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function Bs(e, t, n) { var r; if ("" === t.path) return "full" === t.pathMatch && (e.hasChildren() || n.length > 0) ? Object.assign({}, rv) : { matched: !0, consumedSegments: [], remainingSegments: n, parameters: {}, positionalParamSegments: {} }; const o = (t.matcher || TA)(n, e, t); if (!o) return Object.assign({}, rv); const s = {}; je(o.posParams, (u, l) => { s[l] = u.path }); const a = o.consumed.length > 0 ? Object.assign(Object.assign({}, s), o.consumed[o.consumed.length - 1].parameters) : s; return { matched: !0, consumedSegments: o.consumed, remainingSegments: n.slice(o.consumed.length), parameters: a, positionalParamSegments: null !== (r = o.posParams) && void 0 !== r ? r : {} } } function Vs(e, t, n, r, i = "corrected") { if (n.length > 0 && function yx(e, t, n) { return n.some(r => Hs(e, t, r) && Mt(r) !== $) }(e, n, r)) { const s = new q(t, function mx(e, t, n, r) { const i = {}; i[$] = r, r._sourceSegment = e, r._segmentIndexShift = t.length; for (const o of n) if ("" === o.path && Mt(o) !== $) { const s = new q([], {}); s._sourceSegment = e, s._segmentIndexShift = t.length, i[Mt(o)] = s } return i }(e, t, r, new q(n, e.children))); return s._sourceSegment = e, s._segmentIndexShift = t.length, { segmentGroup: s, slicedSegments: [] } } if (0 === n.length && function vx(e, t, n) { return n.some(r => Hs(e, t, r)) }(e, n, r)) { const s = new q(e.segments, function gx(e, t, n, r, i, o) { const s = {}; for (const a of r) if (Hs(e, n, a) && !i[Mt(a)]) { const u = new q([], {}); u._sourceSegment = e, u._segmentIndexShift = "legacy" === o ? e.segments.length : t.length, s[Mt(a)] = u } return Object.assign(Object.assign({}, i), s) }(e, t, n, r, e.children, i)); return s._sourceSegment = e, s._segmentIndexShift = t.length, { segmentGroup: s, slicedSegments: n } } const o = new q(e.segments, e.children); return o._sourceSegment = e, o._segmentIndexShift = t.length, { segmentGroup: o, slicedSegments: n } } function Hs(e, t, n) { return (!(e.hasChildren() || t.length > 0) || "full" !== n.pathMatch) && "" === n.path } function iv(e, t, n, r) { return !!(Mt(e) === r || r !== $ && Hs(t, n, e)) && ("**" === e.path || Bs(t, e, n).matched) } function ov(e, t, n) { return 0 === t.length && !e.children[n] } class Us { constructor(t) { this.segmentGroup = t || null } } class sv { constructor(t) { this.urlTree = t } } function to(e) { return As(new Us(e)) } function av(e) { return As(new sv(e)) } class wx { constructor(t, n, r, i, o) { this.configLoader = n, this.urlSerializer = r, this.urlTree = i, this.config = o, this.allowRedirects = !0, this.ngModule = t.get(dn) } apply() { const t = Vs(this.urlTree.root, [], [], this.config).segmentGroup, n = new q(t.segments, t.children); return this.expandSegmentGroup(this.ngModule, this.config, n, $).pipe(de(o => this.createUrlTree(Dc(o), this.urlTree.queryParams, this.urlTree.fragment))).pipe(On(o => { if (o instanceof sv) return this.allowRedirects = !1, this.match(o.urlTree); throw o instanceof Us ? this.noMatchError(o) : o })) } match(t) { return this.expandSegmentGroup(this.ngModule, this.config, t.root, $).pipe(de(i => this.createUrlTree(Dc(i), t.queryParams, t.fragment))).pipe(On(i => { throw i instanceof Us ? this.noMatchError(i) : i })) } noMatchError(t) { return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`) } createUrlTree(t, n, r) { const i = t.segments.length > 0 ? new q([], { [$]: t }) : t; return new Yn(i, n, r) } expandSegmentGroup(t, n, r, i) { return 0 === r.segments.length && r.hasChildren() ? this.expandChildren(t, n, r).pipe(de(o => new q([], o))) : this.expandSegment(t, r, n, r.segments, i, !0) } expandChildren(t, n, r) { const i = []; for (const o of Object.keys(r.children)) "primary" === o ? i.unshift(o) : i.push(o); return Fe(i).pipe(Gi(o => { const s = r.children[o], a = nv(n, o); return this.expandSegmentGroup(t, a, s, o).pipe(de(u => ({ segment: u, outlet: o }))) }), wy((o, s) => (o[s.outlet] = s.segment, o), {}), function hA(e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? zr((i, o) => e(i, o, r)) : Fn, ic(1), n ? by(t) : Ey(() => new xs)) }()) } expandSegment(t, n, r, i, o, s) { return Fe(r).pipe(Gi(a => this.expandSegmentAgainstRoute(t, n, r, a, i, o, s).pipe(On(l => { if (l instanceof Us) return V(null); throw l }))), qr(a => !!a), On((a, u) => { if (a instanceof xs || "EmptyError" === a.name) return ov(n, i, o) ? V(new q([], {})) : to(n); throw a })) } expandSegmentAgainstRoute(t, n, r, i, o, s, a) { return iv(i, n, o, s) ? void 0 === i.redirectTo ? this.matchSegmentAgainstRoute(t, n, i, o, s) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, n, r, i, o, s) : to(n) : to(n) } expandSegmentAgainstRouteUsingRedirect(t, n, r, i, o, s) { return "**" === i.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, r, i, s) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, n, r, i, o, s) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, r, i) { const o = this.applyRedirectCommands([], r.redirectTo, {}); return r.redirectTo.startsWith("/") ? av(o) : this.lineralizeSegments(r, o).pipe(xe(s => { const a = new q(s, {}); return this.expandSegment(t, a, n, s, i, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, n, r, i, o, s) { const { matched: a, consumedSegments: u, remainingSegments: l, positionalParamSegments: c } = Bs(n, i, o); if (!a) return to(n); const d = this.applyRedirectCommands(u, i.redirectTo, c); return i.redirectTo.startsWith("/") ? av(d) : this.lineralizeSegments(i, d).pipe(xe(f => this.expandSegment(t, n, r, f.concat(l), s, !1))) } matchSegmentAgainstRoute(t, n, r, i, o) { if ("**" === r.path) return r.loadChildren ? (r._loadedConfig ? V(r._loadedConfig) : this.configLoader.load(t.injector, r)).pipe(de(d => (r._loadedConfig = d, new q(i, {})))) : V(new q(i, {})); const { matched: s, consumedSegments: a, remainingSegments: u } = Bs(n, r, i); return s ? this.getChildConfig(t, r, i).pipe(xe(c => { const d = c.module, f = c.routes, { segmentGroup: h, slicedSegments: p } = Vs(n, a, u, f), m = new q(h.segments, h.children); if (0 === p.length && m.hasChildren()) return this.expandChildren(d, f, m).pipe(de(I => new q(a, I))); if (0 === f.length && 0 === p.length) return V(new q(a, {})); const C = Mt(r) === o; return this.expandSegment(d, m, f, p, C ? $ : o, !0).pipe(de(g => new q(a.concat(g.segments), g.children))) })) : to(n) } getChildConfig(t, n, r) { return n.children ? V(new mc(n.children, t)) : n.loadChildren ? void 0 !== n._loadedConfig ? V(n._loadedConfig) : this.runCanLoadGuards(t.injector, n, r).pipe(xe(i => i ? this.configLoader.load(t.injector, n).pipe(de(o => (n._loadedConfig = o, o))) : function Cx(e) { return As(sc(`Cannot load children because the guard of the route "path: '${e.path}'" returned false`)) }(n))) : V(new mc([], t)) } runCanLoadGuards(t, n, r) { const i = n.canLoad; return i && 0 !== i.length ? V(i.map(s => { const a = t.get(s); let u; if (function ax(e) { return e && Nn(e.canLoad) }(a)) u = a.canLoad(n, r); else { if (!Nn(a)) throw new Error("Invalid CanLoad guard"); u = a(n, r) } return Kt(u) })).pipe(Xi(), ft(s => { if (!Jn(s)) return; const a = sc(`Redirecting to "${this.urlSerializer.serialize(s)}"`); throw a.url = s, a }), de(s => !0 === s)) : V(!0) } lineralizeSegments(t, n) { let r = [], i = n.root; for (; ;) { if (r = r.concat(i.segments), 0 === i.numberOfChildren) return V(r); if (i.numberOfChildren > 1 || !i.children[$]) return As(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t.redirectTo}'`)); i = i.children[$] } } applyRedirectCommands(t, n, r) { return this.applyRedirectCreatreUrlTree(n, this.urlSerializer.parse(n), t, r) } applyRedirectCreatreUrlTree(t, n, r, i) { const o = this.createSegmentGroup(t, n.root, r, i); return new Yn(o, this.createQueryParams(n.queryParams, this.urlTree.queryParams), n.fragment) } createQueryParams(t, n) { const r = {}; return je(t, (i, o) => { if ("string" == typeof i && i.startsWith(":")) { const a = i.substring(1); r[o] = n[a] } else r[o] = i }), r } createSegmentGroup(t, n, r, i) { const o = this.createSegments(t, n.segments, r, i); let s = {}; return je(n.children, (a, u) => { s[u] = this.createSegmentGroup(t, a, r, i) }), new q(o, s) } createSegments(t, n, r, i) { return n.map(o => o.path.startsWith(":") ? this.findPosParam(t, o, i) : this.findOrReturn(o, r)) } findPosParam(t, n, r) { const i = r[n.path.substring(1)]; if (!i) throw new Error(`Cannot redirect to '${t}'. Cannot find '${n.path}'.`); return i } findOrReturn(t, n) { let r = 0; for (const i of n) { if (i.path === t.path) return n.splice(r), i; r++ } return t } } function Dc(e) { const t = {}; for (const r of Object.keys(e.children)) { const o = Dc(e.children[r]); (o.segments.length > 0 || o.hasChildren()) && (t[r] = o) } return function Ex(e) { if (1 === e.numberOfChildren && e.children[$]) { const t = e.children[$]; return new q(e.segments.concat(t.segments), t.children) } return e }(new q(e.segments, t)) } class uv { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class $s { constructor(t, n) { this.component = t, this.route = n } } function Mx(e, t, n) { const r = e._root; return no(r, t ? t._root : null, n, [r.value]) } function zs(e, t, n) { const r = function Tx(e) { if (!e) return null; for (let t = e.parent; t; t = t.parent) { const n = t.routeConfig; if (n && n._loadedConfig) return n._loadedConfig } return null }(t); return (r ? r.module.injector : n).get(e) } function no(e, t, n, r, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = Wr(t); return e.children.forEach(s => { (function Sx(e, t, n, r, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = e.value, s = t ? t.value : null, a = n ? n.getContext(e.value.outlet) : null; if (s && o.routeConfig === s.routeConfig) { const u = function Ax(e, t, n) { if ("function" == typeof n) return n(e, t); switch (n) { case "pathParamsChange": return !Kn(e.url, t.url); case "pathParamsOrQueryParamsChange": return !Kn(e.url, t.url) || !Yt(e.queryParams, t.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !fc(e, t) || !Yt(e.queryParams, t.queryParams); default: return !fc(e, t) } }(s, o, o.routeConfig.runGuardsAndResolvers); u ? i.canActivateChecks.push(new uv(r)) : (o.data = s.data, o._resolvedData = s._resolvedData), no(e, t, o.component ? a ? a.children : null : n, r, i), u && a && a.outlet && a.outlet.isActivated && i.canDeactivateChecks.push(new $s(a.outlet.component, s)) } else s && ro(t, a, i), i.canActivateChecks.push(new uv(r)), no(e, null, o.component ? a ? a.children : null : n, r, i) })(s, o[s.value.outlet], n, r.concat([s.value]), i), delete o[s.value.outlet] }), je(o, (s, a) => ro(s, n.getContext(a), i)), i } function ro(e, t, n) { const r = Wr(e), i = e.value; je(r, (o, s) => { ro(o, i.component ? t ? t.children.getContext(s) : null : t, n) }), n.canDeactivateChecks.push(new $s(i.component && t && t.outlet && t.outlet.isActivated ? t.outlet.component : null, i)) } class jx { } function lv(e) { return new Me(t => t.error(e)) } class Vx { constructor(t, n, r, i, o, s) { this.rootComponentType = t, this.config = n, this.urlTree = r, this.url = i, this.paramsInheritanceStrategy = o, this.relativeLinkResolution = s } recognize() { const t = Vs(this.urlTree.root, [], [], this.config.filter(s => void 0 === s.redirectTo), this.relativeLinkResolution).segmentGroup, n = this.processSegmentGroup(this.config, t, $); if (null === n) return null; const r = new ks([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, $, this.rootComponentType, null, this.urlTree.root, -1, {}), i = new mn(r, n), o = new Wy(this.url, i); return this.inheritParamsAndData(o._root), o } inheritParamsAndData(t) { const n = t.value, r = Gy(n, this.paramsInheritanceStrategy); n.params = Object.freeze(r.params), n.data = Object.freeze(r.data), t.children.forEach(i => this.inheritParamsAndData(i)) } processSegmentGroup(t, n, r) { return 0 === n.segments.length && n.hasChildren() ? this.processChildren(t, n) : this.processSegment(t, n, n.segments, r) } processChildren(t, n) { const r = []; for (const o of Object.keys(n.children)) { const s = n.children[o], a = nv(t, o), u = this.processSegmentGroup(a, s, o); if (null === u) return null; r.push(...u) } const i = cv(r); return function Hx(e) { e.sort((t, n) => t.value.outlet === $ ? -1 : n.value.outlet === $ ? 1 : t.value.outlet.localeCompare(n.value.outlet)) }(i), i } processSegment(t, n, r, i) { for (const o of t) { const s = this.processSegmentAgainstRoute(o, n, r, i); if (null !== s) return s } return ov(n, r, i) ? [] : null } processSegmentAgainstRoute(t, n, r, i) { if (t.redirectTo || !iv(t, n, r, i)) return null; let o, s = [], a = []; if ("**" === t.path) { const h = r.length > 0 ? Py(r).parameters : {}; o = new ks(r, h, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, hv(t), Mt(t), t.component, t, dv(n), fv(n) + r.length, pv(t)) } else { const h = Bs(n, t, r); if (!h.matched) return null; s = h.consumedSegments, a = h.remainingSegments, o = new ks(s, h.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, hv(t), Mt(t), t.component, t, dv(n), fv(n) + s.length, pv(t)) } const u = function Ux(e) { return e.children ? e.children : e.loadChildren ? e._loadedConfig.routes : [] }(t), { segmentGroup: l, slicedSegments: c } = Vs(n, s, a, u.filter(h => void 0 === h.redirectTo), this.relativeLinkResolution); if (0 === c.length && l.hasChildren()) { const h = this.processChildren(u, l); return null === h ? null : [new mn(o, h)] } if (0 === u.length && 0 === c.length) return [new mn(o, [])]; const d = Mt(t) === i, f = this.processSegment(u, l, c, d ? $ : i); return null === f ? null : [new mn(o, f)] } } function $x(e) { const t = e.value.routeConfig; return t && "" === t.path && void 0 === t.redirectTo } function cv(e) { const t = [], n = new Set; for (const r of e) { if (!$x(r)) { t.push(r); continue } const i = t.find(o => r.value.routeConfig === o.value.routeConfig); void 0 !== i ? (i.children.push(...r.children), n.add(i)) : t.push(r) } for (const r of n) { const i = cv(r.children); t.push(new mn(r.value, i)) } return t.filter(r => !n.has(r)) } function dv(e) { let t = e; for (; t._sourceSegment;)t = t._sourceSegment; return t } function fv(e) { let t = e, n = t._segmentIndexShift ? t._segmentIndexShift : 0; for (; t._sourceSegment;)t = t._sourceSegment, n += t._segmentIndexShift ? t._segmentIndexShift : 0; return n - 1 } function hv(e) { return e.data || {} } function pv(e) { return e.resolve || {} } function gv(e) { return [...Object.keys(e), ...Object.getOwnPropertySymbols(e)] } function Cc(e) { return Zn(t => { const n = e(t); return n ? Fe(n).pipe(de(() => t)) : V(t) }) } class Kx extends class Yx { shouldDetach(t) { return !1 } store(t, n) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, n) { return t.routeConfig === n.routeConfig } }{ } const _c = new Z("ROUTES"); class mv { constructor(t, n, r, i) { this.injector = t, this.compiler = n, this.onLoadStartListener = r, this.onLoadEndListener = i } load(t, n) { if (n._loader$) return n._loader$; this.onLoadStartListener && this.onLoadStartListener(n); const i = this.loadModuleFactory(n.loadChildren).pipe(de(o => { this.onLoadEndListener && this.onLoadEndListener(n); const s = o.create(t); return new mc(Ry(s.injector.get(_c, void 0, P.Self | P.Optional)).map(vc), s) }), On(o => { throw n._loader$ = void 0, o })); return n._loader$ = new lA(i, () => new Xt).pipe(_y()), n._loader$ } loadModuleFactory(t) { return Kt(t()).pipe(xe(n => n instanceof kg ? V(n) : Fe(this.compiler.compileModuleAsync(n)))) } } class Xx { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, n) { return t } } function eR(e) { throw e } function tR(e, t, n) { return t.parse("/") } function yv(e, t) { return V(null) } const nR = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, rR = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let ht = (() => { class e { constructor(n, r, i, o, s, a, u) { this.rootComponentType = n, this.urlSerializer = r, this.rootContexts = i, this.location = o, this.config = u, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.navigationId = 0, this.currentPageId = 0, this.isNgZoneEnabled = !1, this.events = new Xt, this.errorHandler = eR, this.malformedUriErrorHandler = tR, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: yv, afterPreactivation: yv }, this.urlHandlingStrategy = new Xx, this.routeReuseStrategy = new Kx, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.canceledNavigationResolution = "replace", this.ngModule = s.get(dn), this.console = s.get(JM); const d = s.get(Le); this.isNgZoneEnabled = d instanceof Le && Le.isInAngularZone(), this.resetConfig(u), this.currentUrlTree = function AA() { return new Yn(new q([], {}), {}, null) }(), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new mv(s, a, f => this.triggerEvent(new Iy(f)), f => this.triggerEvent(new Ty(f))), this.routerState = qy(this.currentUrlTree, this.rootComponentType), this.transitions = new jt({ id: 0, targetPageId: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } get browserPageId() { var n; return null === (n = this.location.getState()) || void 0 === n ? void 0 : n.\u0275routerPageId } setupNavigations(n) { const r = this.events; return n.pipe(zr(i => 0 !== i.id), de(i => Object.assign(Object.assign({}, i), { extractedUrl: this.urlHandlingStrategy.extract(i.rawUrl) })), Zn(i => { let o = !1, s = !1; return V(i).pipe(ft(a => { this.currentNavigation = { id: a.id, initialUrl: a.currentRawUrl, extractedUrl: a.extractedUrl, trigger: a.source, extras: a.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), Zn(a => { const u = this.browserUrlTree.toString(), l = !this.navigated || a.extractedUrl.toString() !== u || u !== this.currentUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || l) && this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl)) return vv(a.source) && (this.browserUrlTree = a.extractedUrl), V(a).pipe(Zn(d => { const f = this.transitions.getValue(); return r.next(new oc(d.id, this.serializeUrl(d.extractedUrl), d.source, d.restoredState)), f !== this.transitions.getValue() ? nn : Promise.resolve(d) }), function bx(e, t, n, r) { return Zn(i => function _x(e, t, n, r, i) { return new wx(e, t, n, r, i).apply() }(e, t, n, i.extractedUrl, r).pipe(de(o => Object.assign(Object.assign({}, i), { urlAfterRedirects: o })))) }(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config), ft(d => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: d.urlAfterRedirects }) }), function zx(e, t, n, r, i) { return xe(o => function Bx(e, t, n, r, i = "emptyOnly", o = "legacy") { try { const s = new Vx(e, t, n, r, i, o).recognize(); return null === s ? lv(new jx) : V(s) } catch (s) { return lv(s) } }(e, t, o.urlAfterRedirects, n(o.urlAfterRedirects), r, i).pipe(de(s => Object.assign(Object.assign({}, o), { targetSnapshot: s })))) }(this.rootComponentType, this.config, d => this.serializeUrl(d), this.paramsInheritanceStrategy, this.relativeLinkResolution), ft(d => { if ("eager" === this.urlUpdateStrategy) { if (!d.extras.skipLocationChange) { const h = this.urlHandlingStrategy.merge(d.urlAfterRedirects, d.rawUrl); this.setBrowserUrl(h, d) } this.browserUrlTree = d.urlAfterRedirects } const f = new mA(d.id, this.serializeUrl(d.extractedUrl), this.serializeUrl(d.urlAfterRedirects), d.targetSnapshot); r.next(f) })); if (l && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: f, extractedUrl: h, source: p, restoredState: m, extras: C } = a, _ = new oc(f, this.serializeUrl(h), p, m); r.next(_); const g = qy(h, this.rootComponentType).snapshot; return V(Object.assign(Object.assign({}, a), { targetSnapshot: g, urlAfterRedirects: h, extras: Object.assign(Object.assign({}, C), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = a.rawUrl, a.resolve(null), nn }), Cc(a => { const { targetSnapshot: u, id: l, extractedUrl: c, rawUrl: d, extras: { skipLocationChange: f, replaceUrl: h } } = a; return this.hooks.beforePreactivation(u, { navigationId: l, appliedUrlTree: c, rawUrlTree: d, skipLocationChange: !!f, replaceUrl: !!h }) }), ft(a => { const u = new yA(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot); this.triggerEvent(u) }), de(a => Object.assign(Object.assign({}, a), { guards: Mx(a.targetSnapshot, a.currentSnapshot, this.rootContexts) })), function xx(e, t) { return xe(n => { const { targetSnapshot: r, currentSnapshot: i, guards: { canActivateChecks: o, canDeactivateChecks: s } } = n; return 0 === s.length && 0 === o.length ? V(Object.assign(Object.assign({}, n), { guardsResult: !0 })) : function Rx(e, t, n, r) { return Fe(e).pipe(xe(i => function Lx(e, t, n, r, i) { const o = t && t.routeConfig ? t.routeConfig.canDeactivate : null; return o && 0 !== o.length ? V(o.map(a => { const u = zs(a, t, i); let l; if (function cx(e) { return e && Nn(e.canDeactivate) }(u)) l = Kt(u.canDeactivate(e, t, n, r)); else { if (!Nn(u)) throw new Error("Invalid CanDeactivate guard"); l = Kt(u(e, t, n, r)) } return l.pipe(qr()) })).pipe(Xi()) : V(!0) }(i.component, i.route, n, t, r)), qr(i => !0 !== i, !0)) }(s, r, i, e).pipe(xe(a => a && function sx(e) { return "boolean" == typeof e }(a) ? function Px(e, t, n, r) { return Fe(t).pipe(Gi(i => rc(function Nx(e, t) { return null !== e && t && t(new _A(e)), V(!0) }(i.route.parent, r), function Ox(e, t) { return null !== e && t && t(new EA(e)), V(!0) }(i.route, r), function kx(e, t, n) { const r = t[t.length - 1], o = t.slice(0, t.length - 1).reverse().map(s => function Ix(e) { const t = e.routeConfig ? e.routeConfig.canActivateChild : null; return t && 0 !== t.length ? { node: e, guards: t } : null }(s)).filter(s => null !== s).map(s => Cy(() => V(s.guards.map(u => { const l = zs(u, s.node, n); let c; if (function lx(e) { return e && Nn(e.canActivateChild) }(l)) c = Kt(l.canActivateChild(r, e)); else { if (!Nn(l)) throw new Error("Invalid CanActivateChild guard"); c = Kt(l(r, e)) } return c.pipe(qr()) })).pipe(Xi()))); return V(o).pipe(Xi()) }(e, i.path, n), function Fx(e, t, n) { const r = t.routeConfig ? t.routeConfig.canActivate : null; if (!r || 0 === r.length) return V(!0); const i = r.map(o => Cy(() => { const s = zs(o, t, n); let a; if (function ux(e) { return e && Nn(e.canActivate) }(s)) a = Kt(s.canActivate(t, e)); else { if (!Nn(s)) throw new Error("Invalid CanActivate guard"); a = Kt(s(t, e)) } return a.pipe(qr()) })); return V(i).pipe(Xi()) }(e, i.route, n))), qr(i => !0 !== i, !0)) }(r, o, e, t) : V(a)), de(a => Object.assign(Object.assign({}, n), { guardsResult: a }))) }) }(this.ngModule.injector, a => this.triggerEvent(a)), ft(a => { if (Jn(a.guardsResult)) { const l = sc(`Redirecting to "${this.serializeUrl(a.guardsResult)}"`); throw l.url = a.guardsResult, l } const u = new vA(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot, !!a.guardsResult); this.triggerEvent(u) }), zr(a => !!a.guardsResult || (this.restoreHistory(a), this.cancelNavigationTransition(a, ""), !1)), Cc(a => { if (a.guards.canActivateChecks.length) return V(a).pipe(ft(u => { const l = new DA(u.id, this.serializeUrl(u.extractedUrl), this.serializeUrl(u.urlAfterRedirects), u.targetSnapshot); this.triggerEvent(l) }), Zn(u => { let l = !1; return V(u).pipe(function qx(e, t) { return xe(n => { const { targetSnapshot: r, guards: { canActivateChecks: i } } = n; if (!i.length) return V(n); let o = 0; return Fe(i).pipe(Gi(s => function Gx(e, t, n, r) { return function Wx(e, t, n, r) { const i = gv(e); if (0 === i.length) return V({}); const o = {}; return Fe(i).pipe(xe(s => function Qx(e, t, n, r) { const i = zs(e, t, r); return Kt(i.resolve ? i.resolve(t, n) : i(t, n)) }(e[s], t, n, r).pipe(ft(a => { o[s] = a }))), ic(1), xe(() => gv(o).length === i.length ? V(o) : nn)) }(e._resolve, e, t, r).pipe(de(o => (e._resolvedData = o, e.data = Object.assign(Object.assign({}, e.data), Gy(e, n).resolve), null))) }(s.route, r, e, t)), ft(() => o++), ic(1), xe(s => o === i.length ? V(n) : nn)) }) }(this.paramsInheritanceStrategy, this.ngModule.injector), ft({ next: () => l = !0, complete: () => { l || (this.restoreHistory(u), this.cancelNavigationTransition(u, "At least one route resolver didn't emit any value.")) } })) }), ft(u => { const l = new CA(u.id, this.serializeUrl(u.extractedUrl), this.serializeUrl(u.urlAfterRedirects), u.targetSnapshot); this.triggerEvent(l) })) }), Cc(a => { const { targetSnapshot: u, id: l, extractedUrl: c, rawUrl: d, extras: { skipLocationChange: f, replaceUrl: h } } = a; return this.hooks.afterPreactivation(u, { navigationId: l, appliedUrlTree: c, rawUrlTree: d, skipLocationChange: !!f, replaceUrl: !!h }) }), de(a => { const u = function WA(e, t, n) { const r = Yi(e, t._root, n ? n._root : void 0); return new zy(r, t) }(this.routeReuseStrategy, a.targetSnapshot, a.currentRouterState); return Object.assign(Object.assign({}, a), { targetRouterState: u }) }), ft(a => { this.currentUrlTree = a.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(a.urlAfterRedirects, a.rawUrl), this.routerState = a.targetRouterState, "deferred" === this.urlUpdateStrategy && (a.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, a), this.browserUrlTree = a.urlAfterRedirects) }), ((e, t, n) => de(r => (new ix(t, r.targetRouterState, r.currentRouterState, n).activate(e), r)))(this.rootContexts, this.routeReuseStrategy, a => this.triggerEvent(a)), ft({ next() { o = !0 }, complete() { o = !0 } }), function pA(e) { return Oe((t, n) => { try { t.subscribe(n) } finally { n.add(e) } }) }(() => { var a; o || s || this.cancelNavigationTransition(i, `Navigation ID ${i.id} is not equal to the current navigation id ${this.navigationId}`), (null === (a = this.currentNavigation) || void 0 === a ? void 0 : a.id) === i.id && (this.currentNavigation = null) }), On(a => { if (s = !0, function IA(e) { return e && e[Ay] }(a)) { const u = Jn(a.url); u || (this.navigated = !0, this.restoreHistory(i, !0)); const l = new My(i.id, this.serializeUrl(i.extractedUrl), a.message); r.next(l), u ? setTimeout(() => { const c = this.urlHandlingStrategy.merge(a.url, this.rawUrlTree), d = { skipLocationChange: i.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy || vv(i.source) }; this.scheduleNavigation(c, "imperative", null, d, { resolve: i.resolve, reject: i.reject, promise: i.promise }) }, 0) : i.resolve(!1) } else { this.restoreHistory(i, !0); const u = new gA(i.id, this.serializeUrl(i.extractedUrl), a); r.next(u); try { i.resolve(this.errorHandler(a)) } catch (l) { i.reject(l) } } return nn })) })) } resetRootComponentType(n) { this.rootComponentType = n, this.routerState.root.component = this.rootComponentType } setTransition(n) { this.transitions.next(Object.assign(Object.assign({}, this.transitions.value), n)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(n => { const r = "popstate" === n.type ? "popstate" : "hashchange"; "popstate" === r && setTimeout(() => { var i; const o = { replaceUrl: !0 }, s = (null === (i = n.state) || void 0 === i ? void 0 : i.navigationId) ? n.state : null; if (s) { const u = Object.assign({}, s); delete u.navigationId, delete u.\u0275routerPageId, 0 !== Object.keys(u).length && (o.state = u) } const a = this.parseUrl(n.url); this.scheduleNavigation(a, r, s, o) }, 0) })) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(n) { this.events.next(n) } resetConfig(n) { tv(n), this.config = n.map(vc), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(n, r = {}) { const { relativeTo: i, queryParams: o, fragment: s, queryParamsHandling: a, preserveFragment: u } = r, l = i || this.routerState.root, c = u ? this.currentUrlTree.fragment : s; let d = null; switch (a) { case "merge": d = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), o); break; case "preserve": d = this.currentUrlTree.queryParams; break; default: d = o || null }return null !== d && (d = this.removeEmptyProps(d)), function YA(e, t, n, r, i) { if (0 === n.length) return hc(t.root, t.root, t.root, r, i); const o = function KA(e) { if ("string" == typeof e[0] && 1 === e.length && "/" === e[0]) return new Yy(!0, 0, e); let t = 0, n = !1; const r = e.reduce((i, o, s) => { if ("object" == typeof o && null != o) { if (o.outlets) { const a = {}; return je(o.outlets, (u, l) => { a[l] = "string" == typeof u ? u.split("/") : u }), [...i, { outlets: a }] } if (o.segmentPath) return [...i, o.segmentPath] } return "string" != typeof o ? [...i, o] : 0 === s ? (o.split("/").forEach((a, u) => { 0 == u && "." === a || (0 == u && "" === a ? n = !0 : ".." === a ? t++ : "" != a && i.push(a)) }), i) : [...i, o] }, []); return new Yy(n, t, r) }(n); if (o.toRoot()) return hc(t.root, t.root, new q([], {}), r, i); const s = function JA(e, t, n) { if (e.isAbsolute) return new pc(t.root, !0, 0); if (-1 === n.snapshot._lastPathIndex) { const o = n.snapshot._urlSegment; return new pc(o, o === t.root, 0) } const r = Ls(e.commands[0]) ? 0 : 1; return function XA(e, t, n) { let r = e, i = t, o = n; for (; o > i;) { if (o -= i, r = r.parent, !r) throw new Error("Invalid number of '../'"); i = r.segments.length } return new pc(r, !1, i - o) }(n.snapshot._urlSegment, n.snapshot._lastPathIndex + r, e.numberOfDoubleDots) }(o, t, e), a = s.processChildren ? js(s.segmentGroup, s.index, o.commands) : Ky(s.segmentGroup, s.index, o.commands); return hc(t.root, s.segmentGroup, a, r, i) }(l, this.currentUrlTree, n, d, null != c ? c : null) } navigateByUrl(n, r = { skipLocationChange: !1 }) { const i = Jn(n) ? n : this.parseUrl(n), o = this.urlHandlingStrategy.merge(i, this.rawUrlTree); return this.scheduleNavigation(o, "imperative", null, r) } navigate(n, r = { skipLocationChange: !1 }) { return function iR(e) { for (let t = 0; t < e.length; t++) { const n = e[t]; if (null == n) throw new Error(`The requested path contains ${n} segment at index ${t}`) } }(n), this.navigateByUrl(this.createUrlTree(n, r), r) } serializeUrl(n) { return this.urlSerializer.serialize(n) } parseUrl(n) { let r; try { r = this.urlSerializer.parse(n) } catch (i) { r = this.malformedUriErrorHandler(i, this.urlSerializer, n) } return r } isActive(n, r) { let i; if (i = !0 === r ? Object.assign({}, nR) : !1 === r ? Object.assign({}, rR) : r, Jn(n)) return Ny(this.currentUrlTree, n, i); const o = this.parseUrl(n); return Ny(this.currentUrlTree, o, i) } removeEmptyProps(n) { return Object.keys(n).reduce((r, i) => { const o = n[i]; return null != o && (r[i] = o), r }, {}) } processNavigations() { this.navigations.subscribe(n => { this.navigated = !0, this.lastSuccessfulId = n.id, this.currentPageId = n.targetPageId, this.events.next(new Wi(n.id, this.serializeUrl(n.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, n.resolve(!0) }, n => { this.console.warn(`Unhandled Navigation Error: ${n}`) }) } scheduleNavigation(n, r, i, o, s) { var a, u; if (this.disposed) return Promise.resolve(!1); let l, c, d; s ? (l = s.resolve, c = s.reject, d = s.promise) : d = new Promise((p, m) => { l = p, c = m }); const f = ++this.navigationId; let h; return "computed" === this.canceledNavigationResolution ? (0 === this.currentPageId && (i = this.location.getState()), h = i && i.\u0275routerPageId ? i.\u0275routerPageId : o.replaceUrl || o.skipLocationChange ? null !== (a = this.browserPageId) && void 0 !== a ? a : 0 : (null !== (u = this.browserPageId) && void 0 !== u ? u : 0) + 1) : h = 0, this.setTransition({ id: f, targetPageId: h, source: r, restoredState: i, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: n, extras: o, resolve: l, reject: c, promise: d, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), d.catch(p => Promise.reject(p)) } setBrowserUrl(n, r) { const i = this.urlSerializer.serialize(n), o = Object.assign(Object.assign({}, r.extras.state), this.generateNgRouterState(r.id, r.targetPageId)); this.location.isCurrentPathEqualTo(i) || r.extras.replaceUrl ? this.location.replaceState(i, "", o) : this.location.go(i, "", o) } restoreHistory(n, r = !1) { var i, o; if ("computed" === this.canceledNavigationResolution) { const s = this.currentPageId - n.targetPageId; "popstate" !== n.source && "eager" !== this.urlUpdateStrategy && this.currentUrlTree !== (null === (i = this.currentNavigation) || void 0 === i ? void 0 : i.finalUrl) || 0 === s ? this.currentUrlTree === (null === (o = this.currentNavigation) || void 0 === o ? void 0 : o.finalUrl) && 0 === s && (this.resetState(n), this.browserUrlTree = n.currentUrlTree, this.resetUrlToCurrentUrlTree()) : this.location.historyGo(s) } else "replace" === this.canceledNavigationResolution && (r && this.resetState(n), this.resetUrlToCurrentUrlTree()) } resetState(n) { this.routerState = n.currentRouterState, this.currentUrlTree = n.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } cancelNavigationTransition(n, r) { const i = new My(n.id, this.serializeUrl(n.extractedUrl), r); this.triggerEvent(i), n.resolve(!1) } generateNgRouterState(n, r) { return "computed" === this.canceledNavigationResolution ? { navigationId: n, \u0275routerPageId: r } : { navigationId: n } } } return e.\u0275fac = function (n) { Hu() }, e.\u0275prov = W({ token: e, factory: e.\u0275fac }), e })(); function vv(e) { return "imperative" !== e } class Dv { } class Cv { preload(t, n) { return V(null) } } let _v = (() => { class e { constructor(n, r, i, o) { this.router = n, this.injector = i, this.preloadingStrategy = o, this.loader = new mv(i, r, u => n.triggerEvent(new Iy(u)), u => n.triggerEvent(new Ty(u))) } setUpPreloading() { this.subscription = this.router.events.pipe(zr(n => n instanceof Wi), Gi(() => this.preload())).subscribe(() => { }) } preload() { const n = this.injector.get(dn); return this.processRoutes(n, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(n, r) { const i = []; for (const o of r) if (o.loadChildren && !o.canLoad && o._loadedConfig) { const s = o._loadedConfig; i.push(this.processRoutes(s.module, s.routes)) } else o.loadChildren && !o.canLoad ? i.push(this.preloadConfig(n, o)) : o.children && i.push(this.processRoutes(n, o.children)); return Fe(i).pipe(Jr(), de(o => { })) } preloadConfig(n, r) { return this.preloadingStrategy.preload(r, () => (r._loadedConfig ? V(r._loadedConfig) : this.loader.load(n.injector, r)).pipe(xe(o => (r._loadedConfig = o, this.processRoutes(o.module, o.routes))))) } } return e.\u0275fac = function (n) { return new (n || e)(R(ht), R(Cm), R(dt), R(Dv)) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac }), e })(), bc = (() => { class e { constructor(n, r, i = {}) { this.router = n, this.viewportScroller = r, this.options = i, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, i.scrollPositionRestoration = i.scrollPositionRestoration || "disabled", i.anchorScrolling = i.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(n => { n instanceof oc ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = n.navigationTrigger, this.restoredId = n.restoredState ? n.restoredState.navigationId : 0) : n instanceof Wi && (this.lastId = n.id, this.scheduleScrollEvent(n, this.router.parseUrl(n.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(n => { n instanceof Sy && (n.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(n.position) : n.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(n.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(n, r) { this.router.triggerEvent(new Sy(n, "popstate" === this.lastSource ? this.store[this.restoredId] : null, r)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return e.\u0275fac = function (n) { Hu() }, e.\u0275prov = W({ token: e, factory: e.\u0275fac }), e })(); const Xn = new Z("ROUTER_CONFIGURATION"), wv = new Z("ROUTER_FORROOT_GUARD"), uR = [kl, { provide: jy, useClass: By }, { provide: ht, useFactory: function hR(e, t, n, r, i, o, s = {}, a, u) { const l = new ht(null, e, t, n, r, i, Ry(o)); return a && (l.urlHandlingStrategy = a), u && (l.routeReuseStrategy = u), function pR(e, t) { e.errorHandler && (t.errorHandler = e.errorHandler), e.malformedUriErrorHandler && (t.malformedUriErrorHandler = e.malformedUriErrorHandler), e.onSameUrlNavigation && (t.onSameUrlNavigation = e.onSameUrlNavigation), e.paramsInheritanceStrategy && (t.paramsInheritanceStrategy = e.paramsInheritanceStrategy), e.relativeLinkResolution && (t.relativeLinkResolution = e.relativeLinkResolution), e.urlUpdateStrategy && (t.urlUpdateStrategy = e.urlUpdateStrategy), e.canceledNavigationResolution && (t.canceledNavigationResolution = e.canceledNavigationResolution) }(s, l), s.enableTracing && l.events.subscribe(c => { var d, f; null === (d = console.group) || void 0 === d || d.call(console, `Router Event: ${c.constructor.name}`), console.log(c.toString()), console.log(c), null === (f = console.groupEnd) || void 0 === f || f.call(console) }), l }, deps: [jy, eo, kl, dt, Cm, _c, Xn, [class Jx { }, new Mn], [class Zx { }, new Mn]] }, eo, { provide: Qr, useFactory: function gR(e) { return e.routerState.root }, deps: [ht] }, _v, Cv, class aR { preload(t, n) { return n().pipe(On(() => V(null))) } }, { provide: Xn, useValue: { enableTracing: !1 } }]; function lR() { return new Mm("Router", ht) } let Mc = (() => { class e { constructor(n, r) { } static forRoot(n, r) { return { ngModule: e, providers: [uR, Ev(n), { provide: wv, useFactory: fR, deps: [[ht, new Mn, new mi]] }, { provide: Xn, useValue: r || {} }, { provide: $r, useFactory: dR, deps: [Qn, [new Po(Fl), new Mn], Xn] }, { provide: bc, useFactory: cR, deps: [ht, fS, Xn] }, { provide: Dv, useExisting: r && r.preloadingStrategy ? r.preloadingStrategy : Cv }, { provide: Mm, multi: !0, useFactory: lR }, [Ic, { provide: vl, multi: !0, useFactory: mR, deps: [Ic] }, { provide: bv, useFactory: yR, deps: [Ic] }, { provide: Dm, multi: !0, useExisting: bv }]] } } static forChild(n) { return { ngModule: e, providers: [Ev(n)] } } } return e.\u0275fac = function (n) { return new (n || e)(R(wv, 8), R(ht, 8)) }, e.\u0275mod = Cn({ type: e }), e.\u0275inj = on({}), e })(); function cR(e, t, n) { return n.scrollOffset && t.setOffset(n.scrollOffset), new bc(e, t, n) } function dR(e, t, n = {}) { return n.useHash ? new zI(e, t) : new zm(e, t) } function fR(e) { return "guarded" } function Ev(e) { return [{ provide: vC, multi: !0, useValue: e }, { provide: _c, multi: !0, useValue: e }] } let Ic = (() => { class e { constructor(n) { this.injector = n, this.initNavigation = !1, this.destroyed = !1, this.resultOfPreactivationDone = new Xt } appInitializer() { return this.injector.get(HI, Promise.resolve(null)).then(() => { if (this.destroyed) return Promise.resolve(!0); let r = null; const i = new Promise(a => r = a), o = this.injector.get(ht), s = this.injector.get(Xn); return "disabled" === s.initialNavigation ? (o.setUpLocationChangeListener(), r(!0)) : "enabled" === s.initialNavigation || "enabledBlocking" === s.initialNavigation ? (o.hooks.afterPreactivation = () => this.initNavigation ? V(null) : (this.initNavigation = !0, r(!0), this.resultOfPreactivationDone), o.initialNavigation()) : r(!0), i }) } bootstrapListener(n) { const r = this.injector.get(Xn), i = this.injector.get(_v), o = this.injector.get(bc), s = this.injector.get(ht), a = this.injector.get(Tl); n === a.components[0] && (("enabledNonBlocking" === r.initialNavigation || void 0 === r.initialNavigation) && s.initialNavigation(), i.setUpPreloading(), o.init(), s.resetRootComponentType(a.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } ngOnDestroy() { this.destroyed = !0 } } return e.\u0275fac = function (n) { return new (n || e)(R(dt)) }, e.\u0275prov = W({ token: e, factory: e.\u0275fac }), e })(); function mR(e) { return e.appInitializer.bind(e) } function yR(e) { return e.bootstrapListener.bind(e) } const bv = new Z("Router Initializer"); let DR = (() => { class e { constructor() { } ngOnInit() { console.log("Header iniciado") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Vt({ type: e, selectors: [["app-header"]], decls: 10, vars: 0, consts: [[1, "menu-header", "font-Yaldevi"]], template: function (n, r) { 1 & n && (he(0, "header")(1, "nav", 0)(2, "div"), nt(3, "Home"), we(), he(4, "div"), nt(5, "About"), we(), he(6, "div"), nt(7, "Projects"), we(), he(8, "div"), nt(9, "Contacts"), we()()()) }, styles: [".menu-header[_ngcontent-%COMP%]{display:flex;justify-content:space-around;margin-left:70%;margin-top:1rem;font-family:Yaldevi,sans-serif;color:azure}.menu-header[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:hover{cursor:pointer;color:#a9a9a9}@media (max-width: 768px){.menu-header[_ngcontent-%COMP%]{display:flex;justify-content:space-around;margin-left:50%;margin-top:1rem}}"] }), e })(), CR = (() => { class e { constructor() { } ngOnInit() { console.log("Menu iniciado") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Vt({ type: e, selectors: [["app-menu"]], decls: 0, vars: 0, template: function (n, r) { }, styles: [""] }), e })(), _R = (() => { class e { constructor() { } ngOnInit() { console.log("body iniciado") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Vt({ type: e, selectors: [["app-body"]], decls: 5, vars: 0, template: function (n, r) { 1 & n && (he(0, "div")(1, "p"), nt(2, "Hi, My Name is Jhonatan, I'm Developer"), we(), he(3, "div"), nt(4, "Lorem ipsum dolor sit amet consectetur adipisicing elit. Eum perspiciatis beatae hic omnis quis. Deserunt architecto illo aperiam eius, eaque officia perspiciatis adipisci nesciunt doloremque dolor perferendis excepturi necessitatibus similique."), we()()) }, styles: ["p[_ngcontent-%COMP%]{position:absolute;top:10%;font-size:3em;white-space:nowrap;overflow:hidden;animation:typewriter 3s steps(50) infinite alternate,blink .8s steps(50) infinite normal;border-right:5px solid black}@keyframes typewriter{0%{width:0%}to{width:58%}}@keyframes blink{0%{border-color:#000}to{border-color:transparent}}"] }), e })(), wR = (() => { class e { constructor() { } ngOnInit() { console.log("footer iniciado") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Vt({ type: e, selectors: [["app-footer"]], decls: 0, vars: 0, template: function (n, r) { }, styles: ["[_nghost-%COMP%]{position:fixed;display:inline-block;top:95%;width:100%;height:5%;background-color:#242424}"] }), e })(), ER = (() => { class e { constructor() { } ngOnInit() { console.log("Main iniciado") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Vt({ type: e, selectors: [["app-main"]], decls: 5, vars: 0, template: function (n, r) { 1 & n && (he(0, "div"), Ye(1, "app-header")(2, "app-menu")(3, "app-body")(4, "app-footer"), we()) }, directives: [DR, CR, _R, wR], styles: ["app-header[_ngcontent-%COMP%]{position:fixed;z-index:1;width:100%;height:5%;background-color:#242424;border:solid 1px red}app-menu[_ngcontent-%COMP%]{position:fixed;top:0%;z-index:0;width:10%;height:100%;background-color:#f0f8ff;box-shadow:0 0 5px -2px #888;border:solid 1px red}app-body[_ngcontent-%COMP%]{position:fixed;top:10%;left:12%;height:85%}app-footer[_ngcontent-%COMP%]{position:fixed;z-index:1;display:inline-block;top:95%;width:100%;height:5%;background-color:#242424;border:solid 1px red}"] }), e })(); var bR = le(808), MR = le.n(bR); const IR = ["sessionHome"], TR = [{ path: "", redirectTo: "/home", pathMatch: "full" }, { path: "home", component: (() => { class e { constructor() { } ngOnInit() { console.log("Web iniciado") } ngAfterViewInit() { new (MR())(".texto", { strings: ["Front-end Developer.", "FullStack.", "Gamer."], loop: !0, typeSpeed: 50, backSpeed: 50, backDelay: 2e3 }) } goLinkedin() { window.open("https://www.linkedin.com/in/jhonatanvago/", "_blank") } goGitHub() { window.open("https://github.com/jhonatanvago", "_blank") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Vt({ type: e, selectors: [["app-web"]], viewQuery: function (n, r) { if (1 & n && Yg(IR, 5), 2 & n) { let i; as(i = function us() { return function OM(e, t) { return e[19].queries[t].queryList }(v(), bd()) }()) && (r.sessionHome = i.first) } }, decls: 38, vars: 0, consts: [[1, "webBody"], [1, "header"], [1, "menu-perfil"], [1, "menu-img"], ["src", "../../../assets/menu-perfil.png", "alt", ""], [1, "menu-nome"], [1, "menu-redes-sociais"], [3, "click"], ["src", "./assets/icons/linkedin.svg", "href", "https://www.linkedin.com/in/jhonatanvago/", "alt", ""], ["src", "../../../assets/icons/github.svg", "alt", ""], [1, "menu-option"], [1, "option-home"], ["src", "../../../assets/icons/home.svg", "alt", ""], [1, "option-About"], ["src", "../../../assets/icons/about.svg", "alt", ""], [1, "option-Projects"], ["src", "../../../assets/icons/projects.svg", "alt", ""], [1, "option-Contacts"], ["src", "../../../assets/icons/contact.svg", "alt", ""], [1, "linha-menu-option"], [1, "session-home"], [1, "texto"]], template: function (n, r) { 1 & n && (he(0, "div", 0)(1, "header", 1)(2, "div", 2)(3, "div", 3), Ye(4, "img", 4), we(), he(5, "label", 5), nt(6, "Jhonatan Mariano Vago"), we(), Ye(7, "br")(8, "br"), he(9, "div", 6)(10, "div", 7), kr("click", function () { return r.goLinkedin() }), Ye(11, "img", 8), we(), he(12, "div", 7), kr("click", function () { return r.goGitHub() }), Ye(13, "img", 9), we()()(), he(14, "div", 10)(15, "div", 11), Ye(16, "img", 12), he(17, "label"), nt(18, "Home"), we()(), he(19, "div", 13), Ye(20, "img", 14), he(21, "label"), nt(22, "About"), we()(), he(23, "div", 15), Ye(24, "img", 16), he(25, "label"), nt(26, "Projects"), we()(), he(27, "div", 17), Ye(28, "img", 18), he(29, "label"), nt(30, "Contacts"), we()()()(), Ye(31, "div", 19), he(32, "div", 20)(33, "h1"), nt(34, "Jhonatan Mariano Vago"), we(), he(35, "p"), nt(36, "I'm "), Ye(37, "span", 21), we()()()) }, styles: [".webBody[_ngcontent-%COMP%]{display:flex;background-color:#1d1b1b;width:100vw;height:100vh}.header[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;background-color:#0897b4;width:15%;min-width:200px;height:100%;font-family:Yaldevi,sans-serif;color:#f0f8ff;border-right:.5px solid aliceblue}.menu-img[_ngcontent-%COMP%]{display:flex;justify-content:center;margin-top:10%;margin-bottom:20px}.menu-img[_ngcontent-%COMP%] > img[_ngcontent-%COMP%]{width:150px;border-radius:50%}.menu-nome[_ngcontent-%COMP%]{font-family:Yaldevi,sans-serif;font-size:24px}.menu-redes-sociais[_ngcontent-%COMP%]{margin-bottom:50px}.menu-redes-sociais[_ngcontent-%COMP%]{display:flex;flex-direction:row;justify-content:center}.menu-redes-sociais[_ngcontent-%COMP%] > div[_ngcontent-%COMP%] > img[_ngcontent-%COMP%]{width:30px;margin-right:15px;cursor:pointer}.menu-redes-sociais[_ngcontent-%COMP%] > div[_ngcontent-%COMP%] > img[_ngcontent-%COMP%]:active{position:relative;top:5px}.menu-option[_ngcontent-%COMP%] > div[_ngcontent-%COMP%] > label[_ngcontent-%COMP%]:hover{color:#a9a9a9;cursor:pointer}.menu-option[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:active{position:relative;top:5px}.menu-option[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{display:flex;align-items:center;margin-bottom:20px}.menu-option[_ngcontent-%COMP%] > div[_ngcontent-%COMP%] > img[_ngcontent-%COMP%]{margin-right:15px}.session-home[_ngcontent-%COMP%]{position:absolute;font-family:Yaldevi,sans-serif;top:40%;font-size:2em;margin-left:40%;white-space:nowrap;overflow:hidden}.session-home[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%]{margin:0 0 10px;font-size:64px;font-weight:700;line-height:56px;color:#fff}.session-home[_ngcontent-%COMP%] > p[_ngcontent-%COMP%]{color:#fff}.session-home[_ngcontent-%COMP%] > p[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{color:#fff;padding-bottom:4px;letter-spacing:1px;border-bottom:3px solid #0897B4}@media (max-width: 768px){.header[_ngcontent-%COMP%]{display:none}}@media (min-width: 1024px){.session-home[_ngcontent-%COMP%]{background-attachment:fixed}}@media (max-width: 768px){.session-home[_ngcontent-%COMP%]{font-size:28px;line-height:36px}.session-home[_ngcontent-%COMP%]{font-size:18px;line-height:24px;margin-bottom:30px;margin-left:0}}"] }), e })() }, { path: "system", component: ER }]; let Mv = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = Cn({ type: e }), e.\u0275inj = on({ imports: [[Mc.forRoot(TR)], Mc] }), e })(), SR = (() => { class e { constructor() { this.title = "portifolio" } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Vt({ type: e, selectors: [["app-root"]], decls: 1, vars: 0, template: function (n, r) { 1 & n && Ye(0, "router-outlet") }, directives: [yc], styles: [""] }), e })(), AR = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = Cn({ type: e }), e.\u0275inj = on({ imports: [[my, Mv, Mc]] }), e })(), xR = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = Cn({ type: e, bootstrap: [SR] }), e.\u0275inj = on({ providers: [], imports: [[my, Mv, AR]] }), e })(); (function CI() { xm = !1 })(), jS().bootstrapModule(xR).catch(e => console.error(e)) }, 808: function (Yr) { Yr.exports = function (gt) { var le = {}; function k(ie) { if (le[ie]) return le[ie].exports; var ee = le[ie] = { exports: {}, id: ie, loaded: !1 }; return gt[ie].call(ee.exports, ee, ee.exports, k), ee.loaded = !0, ee.exports } return k.m = gt, k.c = le, k.p = "", k(0) }([function (gt, le, k) { "use strict"; Object.defineProperty(le, "__esModule", { value: !0 }); var ie = function () { function se(T, D) { for (var E = 0; E < D.length; E++) { var w = D[E]; w.enumerable = w.enumerable || !1, w.configurable = !0, "value" in w && (w.writable = !0), Object.defineProperty(T, w.key, w) } } return function (T, D, E) { return D && se(T.prototype, D), E && se(T, E), T } }(); var Ge = k(1), oe = k(3), Be = function () { function se(T, D) { (function ee(se, T) { if (!(se instanceof T)) throw new TypeError("Cannot call a class as a function") })(this, se), Ge.initializer.load(this, D, T), this.begin() } return ie(se, [{ key: "toggle", value: function () { this.pause.status ? this.start() : this.stop() } }, { key: "stop", value: function () { this.typingComplete || this.pause.status || (this.toggleBlinking(!0), this.pause.status = !0, this.options.onStop(this.arrayPos, this)) } }, { key: "start", value: function () { this.typingComplete || !this.pause.status || (this.pause.status = !1, this.pause.typewrite ? this.typewrite(this.pause.curString, this.pause.curStrPos) : this.backspace(this.pause.curString, this.pause.curStrPos), this.options.onStart(this.arrayPos, this)) } }, { key: "destroy", value: function () { this.reset(!1), this.options.onDestroy(this) } }, { key: "reset", value: function () { var D = arguments.length <= 0 || void 0 === arguments[0] || arguments[0]; clearInterval(this.timeout), this.replaceText(""), this.cursor && this.cursor.parentNode && (this.cursor.parentNode.removeChild(this.cursor), this.cursor = null), this.strPos = 0, this.arrayPos = 0, this.curLoop = 0, D && (this.insertCursor(), this.options.onReset(this), this.begin()) } }, { key: "begin", value: function () { var D = this; this.options.onBegin(this), this.typingComplete = !1, this.shuffleStringsIfNeeded(this), this.insertCursor(), this.bindInputFocusEvents && this.bindFocusEvents(), this.timeout = setTimeout(function () { D.currentElContent && 0 !== D.currentElContent.length ? D.backspace(D.currentElContent, D.currentElContent.length) : D.typewrite(D.strings[D.sequence[D.arrayPos]], D.strPos) }, this.startDelay) } }, { key: "typewrite", value: function (D, E) { var w = this; this.fadeOut && this.el.classList.contains(this.fadeOutClass) && (this.el.classList.remove(this.fadeOutClass), this.cursor && this.cursor.classList.remove(this.fadeOutClass)); var y = this.humanizer(this.typeSpeed), G = 1; !0 !== this.pause.status ? this.timeout = setTimeout(function () { E = oe.htmlParser.typeHtmlChars(D, E, w); var ce = 0, Ve = D.substr(E); if ("^" === Ve.charAt(0) && /^\^\d+/.test(Ve)) { var Jt = 1; Jt += (Ve = /\d+/.exec(Ve)[0]).length, ce = parseInt(Ve), w.temporaryPause = !0, w.options.onTypingPaused(w.arrayPos, w), D = D.substring(0, E) + D.substring(E + Jt), w.toggleBlinking(!0) } if ("`" === Ve.charAt(0)) { for (; "`" !== D.substr(E + G).charAt(0) && (G++, !(E + G > D.length));); var Pe = D.substring(0, E), yn = D.substring(Pe.length + 1, E + G), Kr = D.substring(E + G + 1); D = Pe + yn + Kr, G-- } w.timeout = setTimeout(function () { w.toggleBlinking(!1), E >= D.length ? w.doneTyping(D, E) : w.keepTyping(D, E, G), w.temporaryPause && (w.temporaryPause = !1, w.options.onTypingResumed(w.arrayPos, w)) }, ce) }, y) : this.setPauseStatus(D, E, !0) } }, { key: "keepTyping", value: function (D, E, w) { 0 === E && (this.toggleBlinking(!1), this.options.preStringTyped(this.arrayPos, this)); var y = D.substr(0, E += w); this.replaceText(y), this.typewrite(D, E) } }, { key: "doneTyping", value: function (D, E) { var w = this; this.options.onStringTyped(this.arrayPos, this), this.toggleBlinking(!0), (this.arrayPos !== this.strings.length - 1 || (this.complete(), !1 !== this.loop && this.curLoop !== this.loopCount)) && (this.timeout = setTimeout(function () { w.backspace(D, E) }, this.backDelay)) } }, { key: "backspace", value: function (D, E) { var w = this; if (!0 !== this.pause.status) { if (this.fadeOut) return this.initFadeOut(); this.toggleBlinking(!1); var y = this.humanizer(this.backSpeed); this.timeout = setTimeout(function () { E = oe.htmlParser.backSpaceHtmlChars(D, E, w); var G = D.substr(0, E); if (w.replaceText(G), w.smartBackspace) { var ce = w.strings[w.arrayPos + 1]; w.stopNum = ce && G === ce.substr(0, E) ? E : 0 } E > w.stopNum ? (E--, w.backspace(D, E)) : E <= w.stopNum && (w.arrayPos++, w.arrayPos === w.strings.length ? (w.arrayPos = 0, w.options.onLastStringBackspaced(), w.shuffleStringsIfNeeded(), w.begin()) : w.typewrite(w.strings[w.sequence[w.arrayPos]], E)) }, y) } else this.setPauseStatus(D, E, !1) } }, { key: "complete", value: function () { this.options.onComplete(this), this.loop ? this.curLoop++ : this.typingComplete = !0 } }, { key: "setPauseStatus", value: function (D, E, w) { this.pause.typewrite = w, this.pause.curString = D, this.pause.curStrPos = E } }, { key: "toggleBlinking", value: function (D) { !this.cursor || this.pause.status || this.cursorBlinking !== D && (this.cursorBlinking = D, D ? this.cursor.classList.add("typed-cursor--blink") : this.cursor.classList.remove("typed-cursor--blink")) } }, { key: "humanizer", value: function (D) { return Math.round(Math.random() * D / 2) + D } }, { key: "shuffleStringsIfNeeded", value: function () { !this.shuffle || (this.sequence = this.sequence.sort(function () { return Math.random() - .5 })) } }, { key: "initFadeOut", value: function () { var D = this; return this.el.className += " " + this.fadeOutClass, this.cursor && (this.cursor.className += " " + this.fadeOutClass), setTimeout(function () { D.arrayPos++, D.replaceText(""), D.strings.length > D.arrayPos ? D.typewrite(D.strings[D.sequence[D.arrayPos]], 0) : (D.typewrite(D.strings[0], 0), D.arrayPos = 0) }, this.fadeOutDelay) } }, { key: "replaceText", value: function (D) { this.attr ? this.el.setAttribute(this.attr, D) : this.isInput ? this.el.value = D : "html" === this.contentType ? this.el.innerHTML = D : this.el.textContent = D } }, { key: "bindFocusEvents", value: function () { var D = this; !this.isInput || (this.el.addEventListener("focus", function (E) { D.stop() }), this.el.addEventListener("blur", function (E) { D.el.value && 0 !== D.el.value.length || D.start() })) } }, { key: "insertCursor", value: function () { !this.showCursor || this.cursor || (this.cursor = document.createElement("span"), this.cursor.className = "typed-cursor", this.cursor.setAttribute("aria-hidden", !0), this.cursor.innerHTML = this.cursorChar, this.el.parentNode && this.el.parentNode.insertBefore(this.cursor, this.el.nextSibling)) } }]), se }(); le.default = Be, gt.exports = le.default }, function (gt, le, k) { "use strict"; Object.defineProperty(le, "__esModule", { value: !0 }); var ie = Object.assign || function (E) { for (var w = 1; w < arguments.length; w++) { var y = arguments[w]; for (var G in y) Object.prototype.hasOwnProperty.call(y, G) && (E[G] = y[G]) } return E }, ee = function () { function E(w, y) { for (var G = 0; G < y.length; G++) { var ce = y[G]; ce.enumerable = ce.enumerable || !1, ce.configurable = !0, "value" in ce && (ce.writable = !0), Object.defineProperty(w, ce.key, ce) } } return function (w, y, G) { return y && E(w.prototype, y), G && E(w, G), w } }(); var se = function Ge(E) { return E && E.__esModule ? E : { default: E } }(k(2)), T = function () { function E() { !function oe(E, w) { if (!(E instanceof w)) throw new TypeError("Cannot call a class as a function") }(this, E) } return ee(E, [{ key: "load", value: function (y, G, ce) { if (y.el = "string" == typeof ce ? document.querySelector(ce) : ce, y.options = ie({}, se.default, G), y.isInput = "input" === y.el.tagName.toLowerCase(), y.attr = y.options.attr, y.bindInputFocusEvents = y.options.bindInputFocusEvents, y.showCursor = !y.isInput && y.options.showCursor, y.cursorChar = y.options.cursorChar, y.cursorBlinking = !0, y.elContent = y.attr ? y.el.getAttribute(y.attr) : y.el.textContent, y.contentType = y.options.contentType, y.typeSpeed = y.options.typeSpeed, y.startDelay = y.options.startDelay, y.backSpeed = y.options.backSpeed, y.smartBackspace = y.options.smartBackspace, y.backDelay = y.options.backDelay, y.fadeOut = y.options.fadeOut, y.fadeOutClass = y.options.fadeOutClass, y.fadeOutDelay = y.options.fadeOutDelay, y.isPaused = !1, y.strings = y.options.strings.map(function (Kr) { return Kr.trim() }), y.stringsElement = "string" == typeof y.options.stringsElement ? document.querySelector(y.options.stringsElement) : y.options.stringsElement, y.stringsElement) { y.strings = [], y.stringsElement.style.display = "none"; var Ve = Array.prototype.slice.apply(y.stringsElement.children), Jt = Ve.length; if (Jt) for (var Pe = 0; Pe < Jt; Pe += 1)y.strings.push(Ve[Pe].innerHTML.trim()) } for (var Pe in y.strPos = 0, y.arrayPos = 0, y.stopNum = 0, y.loop = y.options.loop, y.loopCount = y.options.loopCount, y.curLoop = 0, y.shuffle = y.options.shuffle, y.sequence = [], y.pause = { status: !1, typewrite: !0, curString: "", curStrPos: 0 }, y.typingComplete = !1, y.strings) y.sequence[Pe] = Pe; y.currentElContent = this.getCurrentElContent(y), y.autoInsertCss = y.options.autoInsertCss, this.appendAnimationCss(y) } }, { key: "getCurrentElContent", value: function (y) { return y.attr ? y.el.getAttribute(y.attr) : y.isInput ? y.el.value : "html" === y.contentType ? y.el.innerHTML : y.el.textContent } }, { key: "appendAnimationCss", value: function (y) { var G = "data-typed-js-css"; if (y.autoInsertCss && (y.showCursor || y.fadeOut) && !document.querySelector("[" + G + "]")) { var ce = document.createElement("style"); ce.type = "text/css", ce.setAttribute(G, !0); var Ve = ""; y.showCursor && (Ve += "\n        .typed-cursor{\n          opacity: 1;\n        }\n        .typed-cursor.typed-cursor--blink{\n          animation: typedjsBlink 0.7s infinite;\n          -webkit-animation: typedjsBlink 0.7s infinite;\n                  animation: typedjsBlink 0.7s infinite;\n        }\n        @keyframes typedjsBlink{\n          50% { opacity: 0.0; }\n        }\n        @-webkit-keyframes typedjsBlink{\n          0% { opacity: 1; }\n          50% { opacity: 0.0; }\n          100% { opacity: 1; }\n        }\n      "), y.fadeOut && (Ve += "\n        .typed-fade-out{\n          opacity: 0;\n          transition: opacity .25s;\n        }\n        .typed-cursor.typed-cursor--blink.typed-fade-out{\n          -webkit-animation: 0;\n          animation: 0;\n        }\n      "), 0 !== ce.length && (ce.innerHTML = Ve, document.body.appendChild(ce)) } } }]), E }(); le.default = T; var D = new T; le.initializer = D }, function (gt, le) { "use strict"; Object.defineProperty(le, "__esModule", { value: !0 }), le.default = { strings: ["These are the default values...", "You know what you should do?", "Use your own!", "Have a great day!"], stringsElement: null, typeSpeed: 0, startDelay: 0, backSpeed: 0, smartBackspace: !0, shuffle: !1, backDelay: 700, fadeOut: !1, fadeOutClass: "typed-fade-out", fadeOutDelay: 500, loop: !1, loopCount: 1 / 0, showCursor: !0, cursorChar: "|", autoInsertCss: !0, attr: null, bindInputFocusEvents: !1, contentType: "html", onBegin: function (ee) { }, onComplete: function (ee) { }, preStringTyped: function (ee, Ge) { }, onStringTyped: function (ee, Ge) { }, onLastStringBackspaced: function (ee) { }, onTypingPaused: function (ee, Ge) { }, onTypingResumed: function (ee, Ge) { }, onReset: function (ee) { }, onStop: function (ee, Ge) { }, onStart: function (ee, Ge) { }, onDestroy: function (ee) { } }, gt.exports = le.default }, function (gt, le) { "use strict"; Object.defineProperty(le, "__esModule", { value: !0 }); var k = function () { function oe(Be, se) { for (var T = 0; T < se.length; T++) { var D = se[T]; D.enumerable = D.enumerable || !1, D.configurable = !0, "value" in D && (D.writable = !0), Object.defineProperty(Be, D.key, D) } } return function (Be, se, T) { return se && oe(Be.prototype, se), T && oe(Be, T), Be } }(); var ee = function () { function oe() { !function ie(oe, Be) { if (!(oe instanceof Be)) throw new TypeError("Cannot call a class as a function") }(this, oe) } return k(oe, [{ key: "typeHtmlChars", value: function (se, T, D) { if ("html" !== D.contentType) return T; var E = se.substr(T).charAt(0); if ("<" === E || "&" === E) { var w; for (w = "<" === E ? ">" : ";"; se.substr(T + 1).charAt(0) !== w && !(1 + ++T > se.length);); T++ } return T } }, { key: "backSpaceHtmlChars", value: function (se, T, D) { if ("html" !== D.contentType) return T; var E = se.substr(T).charAt(0); if (">" === E || ";" === E) { var w; for (w = ">" === E ? "<" : "&"; se.substr(T - 1).charAt(0) !== w && !(--T < 0);); T-- } return T } }]), oe }(); le.default = ee; var Ge = new ee; le.htmlParser = Ge }]) } }, Yr => { Yr(Yr.s = 434) }]);